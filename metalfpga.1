.TH METALFPGA 1 "December 2025" "v0.7+" "User Commands"
.SH NAME
metalfpga \- Verilog-to-Metal (MSL) compiler for GPU-based hardware simulation
.SH SYNOPSIS
.B metalfpga
.I input.v
[\fImore.v\fR ...]
[\fIOPTIONS\fR]
.SH DESCRIPTION
.B metalfpga
is a "GPGA" (GPU-based FPGA) compiler that parses and lowers a large, practical
subset of Verilog (spanning RTL and common testbench semantics) into Metal Shading
Language compute kernels. This enables FPGA designers to prototype and validate
hardware designs on Apple GPUs before synthesis to actual hardware, leveraging
massive parallelism for fast simulation.
.PP
The compiler performs the following operations:
.IP \[bu] 2
Parses Verilog RTL and testbench constructs
.IP \[bu]
Flattens module hierarchy through elaboration
.IP \[bu]
Generates Metal compute shaders for GPU execution
.IP \[bu]
Emits host-side runtime scaffolding
.PP
.B Current Status:
v0.7+ -
.B Verilog frontend 100% complete + GPU runtime functional + VCD waveform generation + Wide integer support + IEEE 754 math functions:
Full Verilog-2005 parsing, elaboration, and MSL codegen, plus Metal runtime
with GPU execution and industry-standard VCD waveform output. Includes
software double-precision float (IEEE 754) with 13 math functions ($log10, $ln, $exp, $sqrt, $pow, $floor, $ceil,
$sin, $cos, $tan, $asin, $acos, $atan), wide integers (128-bit, 256-bit, arbitrary width),
command-line arguments ($test$plusargs, $value$plusargs), User-Defined Primitives (UDPs),
match-3 operators (===, !==, ==?, !=?), power operator (**),
multi-dimensional arrays, procedural part-select assignment, and dynamic repeat loops.
Full VCD debugging support with $dumpfile, $dumpvars, dump control ($dumpoff/$dumpon),
and $readmemh/$readmemb. 14 file I/O functions including $fopen, $fseek, $fread, $ungetc, $ferror.
Extensive support for generate blocks, 4-state logic, signed arithmetic, system tasks,
timing controls, and switch-level primitives. 400 total test files validate the compiler pipeline.
.B Next phase: Full test suite validation on GPU (v1.0).
.SH OPTIONS
.TP
.BR \-\-emit\-msl " \fIPATH\fR"
Generate Metal Shading Language compute kernel and write to \fIPATH\fR.
The output file will contain GPU-executable shader code for the elaborated design.
.TP
.BR \-\-emit\-host " \fIPATH\fR"
Generate host runtime stub and write to \fIPATH\fR.
The output file will contain Objective-C++ code for interfacing with the Metal runtime.
.TP
.BR \-\-dump\-flat
Dump the flattened netlist to standard output.
Shows the elaborated design including ports, nets, assigns, and always blocks
with hierarchical-to-flat name mappings.
.TP
.BR \-\-top " \fIMODULE\fR"
Specify top-level module name.
Required when the input contains multiple module definitions.
.TP
.BR \-\-4state
Enable 4-state logic (0/1/X/Z) support.
When enabled, the compiler handles X (unknown) and Z (high-impedance) values
and their propagation through operations. Required for
.BR casex " and " casez
statements.
.TP
.BR \-\-auto
Auto-discover Verilog modules under the input file's directory tree.
Recursively searches for .v files in the same directory and subdirectories
as the input file, automatically including them in compilation.
.TP
.BR \-\-run
Execute the compiled design on GPU (automatically generates MSL and host code).
Compiles the generated MSL and host code, then runs the simulation on Metal.
.TP
.BR \-\-vcd\-dir " \fIPATH\fR"
Specify output directory for VCD waveform files.
VCD files generated by $dumpfile will be written to this directory.
Creates parent directories if needed.
.TP
.BR \-\-count " \fIN\fR"
Set number of parallel kernel instances for GPU execution (default: 1).
.TP
.BR \-\-max\-steps " \fIN\fR"
Set maximum scheduler steps per GPU dispatch (default: 1000).
.TP
.BR \-\-service\-capacity " \fIN\fR"
Set service record buffer capacity for system tasks (default: 1024).
.TP
.BR \-\-dispatch\-timeout\-ms " \fIN\fR"
Set GPU dispatch timeout in milliseconds.
.TP
.BR \-\-run\-verbose
Enable verbose runtime output for debugging.
.TP
.BR \-\-source\-bindings
Prefer source-level shader bindings (debug mode, slower compilation).
.TP
.BR + \fIARG\fR[=\fIVALUE\fR]
Pass command-line arguments (plusargs) for $test$plusargs and $value$plusargs.
Example: +DEBUG +WIDTH=128
.SH SUPPORTED VERILOG FEATURES
.SS Module System
.IP \[bu] 2
Module declarations with hierarchy and parameters
.IP \[bu]
Port declarations: input, output, inout
.IP \[bu]
Port connections (named and positional)
.IP \[bu]
Multi-file input
.IP \[bu]
Parameters and localparams with expressions
.SS Data Types
.IP \[bu] 2
Wire and reg declarations with bit-widths
.IP \[bu]
Unpacked arrays
.IP \[bu]
Memory arrays (multi-dimensional supported)
.IP \[bu]
Signed arithmetic with
.B signed
keyword
.SS Assignments
.IP \[bu] 2
Continuous assignments (assign)
.IP \[bu]
Blocking assignments (=)
.IP \[bu]
Non-blocking assignments (<=)
.SS Always Blocks
.IP \[bu] 2
Combinational (always @*)
.IP \[bu]
Sequential (always @(posedge clk), always @(negedge clk))
.IP \[bu]
Initial blocks
.SS Control Flow
.IP \[bu] 2
If/else statements
.IP \[bu]
Case statements (case, casex, casez)
.IP \[bu]
For/while loops (constant bounds, unrolled during elaboration)
.IP \[bu]
Repeat loops (both constant and dynamic/runtime-evaluated counts)
.SS Generate Constructs
.IP \[bu] 2
Generate blocks with genvar
.IP \[bu]
For-generate
.IP \[bu]
If-generate
.SS Functions
.IP \[bu] 2
Functions with inputs and single return assignment
.IP \[bu]
Inlined during elaboration
.SS Operators
.IP \[bu] 2
Arithmetic: +, -, *, /, %, ** (power/exponentiation)
.IP \[bu]
Bitwise: &, |, ^, ~
.IP \[bu]
Reduction: &, |, ^, ~&, ~|, ~^
.IP \[bu]
Logical: &&, ||, !
.IP \[bu]
Shifts: <<, >>, <<<, >>>
.IP \[bu]
Comparison: ==, !=, <, >, <=, >=
.IP \[bu]
Case equality: ===, !== (exact bit-for-bit match including X/Z, requires --4state)
.IP \[bu]
Wildcard match: ==?, !=? (pattern matching with X/Z as don't-care, requires --4state)
.IP \[bu]
Ternary: ? :
.SS Bit Operations
.IP \[bu] 2
Bit selects: signal[3]
.IP \[bu]
Part selects: signal[7:0]
.IP \[bu]
Indexed part selects: signal[i +: 4], signal[i -: 4]
.IP \[bu]
Part-select assignment (procedural): data[7:0] = value, data[idx +: 4] = value
.IP \[bu]
Concatenation: {a, b, c}
.IP \[bu]
Replication: {4{1'b0}}
.IP \[bu]
String literals: "Hello" - Converted to packed ASCII bit values (little-endian, up to 8 characters/64 bits)
.IP \[bu]
Wide integers: Arbitrary-width literals and operations (128-bit, 256-bit, etc.) - Wide literals (128'hDEADBEEF), multi-word arithmetic with carry/borrow, dynamic shifts across 64-bit boundaries
.SS System Functions and Tasks
.IP \[bu] 2
Type casting: $signed(...), $unsigned(...)
.IP \[bu]
Math: $clog2(...), $bits(...)
.IP \[bu]
Output: $display, $write, $strobe - Console output with format specifiers
.IP \[bu]
Monitoring: $monitor - Continuous value watching
.IP \[bu]
Control: $finish, $stop - Simulation control
.IP \[bu]
Time: $time (64-bit), $stime (32-bit), $realtime - Time retrieval
.IP \[bu]
Formatting: $timeformat, $printtimescale
.IP \[bu]
Memory I/O: $readmemh, $readmemb, $writememh, $writememb - Memory initialization and dump
.IP \[bu]
Waveform: $dumpfile, $dumpvars, $dumpall, $dumpon, $dumpoff, $dumpflush, $dumplimit - Full VCD waveform generation with dump control
.IP \[bu]
File I/O: $fopen, $fclose, $fgetc, $fgets, $feof, $ftell, $rewind, $fseek, $fread, $ungetc, $ferror, $fflush, $fscanf, $sscanf - File operations (14 functions, infrastructure complete, runtime execution pending)
.IP \[bu]
String: $sformat - String formatting
.IP \[bu]
Real conversion: $itor, $rtoi, $realtobits, $bitstoreal
.IP \[bu]
Real math: $log10, $ln, $exp, $sqrt, $pow, $floor, $ceil, $sin, $cos, $tan, $asin, $acos, $atan - Mathematical functions (13 functions)
.IP \[bu]
Command-line args: $test$plusargs, $value$plusargs - Runtime configuration via +ARG syntax
.SS Tasks and Time
.IP \[bu] 2
Tasks (procedural task blocks with inputs/outputs)
.IP \[bu]
time data type and time system functions
.IP \[bu]
Named events (event keyword and -> trigger)
.IP \[bu]
Timing delays (# delay syntax)
.IP \[bu]
timescale directive
.SS User-Defined Primitives (UDPs)
.IP \[bu] 2
Combinational UDPs (truth tables)
.IP \[bu]
Sequential UDPs (state machines with current/next state)
.IP \[bu]
Edge-sensitive UDPs (posedge/negedge detection)
.IP \[bu]
Level-sensitive UDPs (transparent latches)
.SS Real Number Arithmetic
.IP \[bu] 2
real data type for IEEE 754 double-precision floating-point (software emulation using ulong - Metal GPUs lack native double hardware)
.IP \[bu]
Real literals: 3.14, 1.5e-10, .5, 5.
.IP \[bu]
Real arrays and parameters (e.g., parameter real PI = $acos(-1.0);)
.IP \[bu]
17,113-line IEEE 754 implementation in include/gpga_real.h with dynamic library caching
.IP \[bu]
Arithmetic operators: +, -, *, /, ** (power)
.IP \[bu]
Comparison operators: <, >, <=, >=, ==, !=
.IP \[bu]
Math functions (13 functions): $log10, $ln, $exp, $sqrt, $pow, $floor, $ceil, $sin, $cos, $tan, $asin, $acos, $atan
.IP \[bu]
Mixed integer/real arithmetic with automatic promotion
.IP \[bu]
Real constant expressions in parameters and generate blocks (including math functions)
.IP \[bu]
Special values: NaN, Infinity, Â±0, denormals fully supported
.SS Switch-Level Modeling
.IP \[bu] 2
Transmission gates: tran, tranif0, tranif1, rtran, rtranif0, rtranif1
.IP \[bu]
MOS switches: nmos, pmos, rnmos, rpmos, cmos, rcmos
.IP \[bu]
Drive strengths: supply0, supply1, strong0, strong1, pull0, pull1, weak0, weak1, highz0, highz1
.IP \[bu]
Net types: wire, wand, wor, tri, triand, trior, tri0, tri1, supply0, supply1, trireg
.SS 4-State Logic
With
.BR \-\-4state :
.IP \[bu] 2
X/Z literals (8'bz, 4'b10zx, etc.)
.IP \[bu]
X/Z propagation in operations
.IP \[bu]
casex and casez statements
.SH ERROR DETECTION
The compiler detects and reports:
.IP \[bu] 2
Combinational loops
.IP \[bu]
Multiple drivers on regs or mixed always/assign conflicts (wire multi-drive is resolved in 4-state)
.IP \[bu]
Recursive module instantiation
.IP \[bu]
Undeclared signals
.IP \[bu]
Width mismatches (with warnings)
.SH EXAMPLES
.TP
Check syntax and elaborate design:
.B metalfpga
.I design.v
.TP
Dump flattened netlist:
.B metalfpga
.I design.v
.B \-\-dump\-flat
.TP
Generate Metal shader code:
.B metalfpga
.I design.v
.B \-\-emit\-msl
.I output.metal
.TP
Generate host runtime stub:
.B metalfpga
.I design.v
.B \-\-emit\-host
.I output.mm
.TP
Specify top module:
.B metalfpga
.I design.v
.B \-\-top
.I module_name
.TP
Enable 4-state logic:
.B metalfpga
.I design.v
.B \-\-4state
.TP
Multiple files with top specification:
.B metalfpga
.I file_a.v file_b.v
.B \-\-top
.I top
.TP
Auto-discover modules:
.B metalfpga
.I top.v
.B \-\-auto \-\-top
.I top
.TP
Full workflow example:
.B metalfpga
.I design.v
.B \-\-emit\-msl
.I design.metal
.B \-\-emit\-host
.I design.mm
.B \-\-4state
.TP
Run with VCD waveform output:
.B metalfpga
.I testbench.v
.B \-\-run \-\-vcd\-dir
.I ./waves/
.TP
Run with command-line arguments (plusargs):
.B metalfpga
.I testbench.v
.B \-\-run
.B +DEBUG +WIDTH=128 +TESTNAME=smoke
.SH TEST RUNNER
The
.B test_runner.sh
script provides automated testing of the compiler. It supports multiple modes
for different testing scenarios.
.SS Test Runner Modes
.TP
.B ./test_runner.sh
Quick smoke test (1 file, ~2 seconds) - For rapid development iteration
.TP
.B ./test_runner.sh \-\-full
Comprehensive test suite (400 files, ~3 minutes) - For regression testing
.TP
.B ./test_runner.sh \-\-4state
Force 4-state mode for all tests - Tests X/Z logic paths
.TP
.B ./test_runner.sh \-\-2state
Force 2-state mode (tests requiring X/Z marked N/A) - Tests 2-state optimizations
.TP
.B ./test_runner.sh \-\-sysverilog
Run SystemVerilog tests (expected failures) - Track SystemVerilog compatibility
.TP
.B ./test_runner.sh \-\-auto
Enable auto-discovery mode for all tests
.SS Test Results
Test results are saved to
.I artifacts/<RUN_ID>/
with generated MSL files, test logs, and flattened netlists.
.SH EXIT STATUS
.TP
.B 0
Successful elaboration
.TP
.B 1
Parsing or elaboration error
.TP
.B 2
Invalid command-line arguments
.SH FILES
.TP
.I verilog/test_v1_ready_do_not_move.v
Smoke test for quick validation (1 file, runs in ~2 seconds)
.TP
.I verilog/pass/*.v
Comprehensive test suite (400 files, requires --full flag, runs in ~3 minutes)
.TP
.I verilog/systemverilog/*.v
SystemVerilog test suite (18 files, expected to fail)
.TP
.I docs/gpga/README.md
Project architecture and goals
.TP
.I docs/gpga/verilog_words.md
Verilog keyword implementation status
.TP
.I docs/gpga/ir_invariants.md
Flattened netlist invariants
.TP
.I docs/4STATE.md
4-state logic design document
.TP
.I docs/gpga_4state_api.md
Complete MSL 4-state library reference (100+ functions)
.TP
.I docs/GPGA_KEYWORDS.md
GPGA keywords reference - All gpga_* and __gpga_* keywords used in generated MSL (power ops, real number operations, math functions, wide integers, double precision internals)
.TP
.I docs/GPGA_REAL_API.md
GPGA Real Library API reference - Complete documentation for 346+ IEEE 754 functions (2,463 lines)
.TP
.I docs/SOFTFLOAT64_IMPLEMENTATION.md
Software double-precision float implementation (IEEE 754 emulation, 29 functions)
.TP
.I docs/APP_BUNDLING.md
Vision for compiling HDL to native macOS applications
.TP
.I docs/CRLIBM_PORTING.md
CRlibm porting plan - Roadmap for correctly rounded elementary functions
.TP
.I docs/diff/
REV documents tracking commit-by-commit changes (REV0-REV35)
.TP
.I include/gpga_real.h
IEEE 754 binary64 library (17,113 lines) - Software double-precision implementation
.TP
.I include/gpga_real_decl.h
Forward declarations for gpga_real.h
.TP
.I verilog/test_vcd_*.v
VCD waveform generation tests (12 files)
.TP
.I verilog/test_repeat_dynamic.v
Dynamic repeat loop test
.TP
.I verilog/test_real_math.v
Real math functions test (13 math functions)
.TP
.I verilog/test_wide_*.v
Wide integer tests (128-bit, 256-bit, 5+ files)
.TP
.I verilog/test_system_*.v
File I/O system task tests (15+ files)
.SH NOTES
.SS Test Suite Status
400 total test files validate the compiler pipeline. The test suite validates
parsing, elaboration, MSL codegen output quality, semantic correctness, and
VCD waveform generation.
Test coverage includes UDPs (4 tests), real number arithmetic (13+ tests including all 13 math functions),
casez/casex pattern matching (16 tests), defparam hierarchical override (9 tests),
generate blocks (23 tests), timing semantics (14 tests), switch-level primitives
(23 tests), VCD waveform generation (12 tests), dynamic repeat loops (1 test),
wide integers (11+ tests including wide VCD, wide file I/O, wide memory operations),
file I/O (14 functions, 15+ tests),
match-3 operators, part-select assignment, reduction operators,
signed arithmetic, 4-state logic, system tasks, multi-dimensional arrays, and
advanced net types.
.PP
The default test run (./test_runner.sh) executes a single smoke test for rapid
iteration during development. Use ./test_runner.sh --full for comprehensive
regression testing (400 files).
.SS Frontend Status
.B Complete:
The Verilog frontend is feature-complete. The compiler successfully parses,
elaborates, and generates MSL code for the full Verilog-2005 language. The
emitted MSL is structurally sound and implements intended semantics.
.PP
.B Runtime Status:
The Metal runtime infrastructure is fully functional. VCD waveform generation
is complete and working with full dump control support. Software double-precision
float (IEEE 754) is implemented using ulong emulation with 17,113-line library
in include/gpga_real.h, providing 13 math functions ($log10, $ln, $exp, $sqrt, $pow,
$floor, $ceil, $sin, $cos, $tan, $asin, $acos, $atan). Dynamic library caching
optimizes compilation performance (first run ~2-3s, subsequent runs instant).
File I/O infrastructure is complete with all 14 functions implemented
($readmemh/$readmemb, $fopen/$fclose, $fseek/$ftell/$rewind, $fread/$fgetc/$fgets,
$ungetc, $ferror/$fflush, $fscanf/$sscanf). Command-line argument support
($test$plusargs, $value$plusargs) enables runtime configuration via +ARG syntax.
Features awaiting full validation include:
.IP \[bu] 2
Event scheduling behavior under GPU dispatch
.IP \[bu]
$display/$monitor/$strobe format string parsing and output
.IP \[bu]
Timing controls (#delay) in real-time execution
.IP \[bu]
Switch-level resolution under GPU scheduling
.IP \[bu]
Non-blocking assignment scheduling semantics
.SS Not Yet Implemented
.IP \[bu] 2
Full test suite validation on GPU (smoke test and VCD tests pass)
.IP \[bu]
$display/$monitor/$strobe format string parsing
.IP \[bu]
Full sensitivity list support beyond @* and @(posedge/negedge clk)
.IP \[bu]
SystemVerilog constructs (classes, interfaces, packages, assertions)
.SS Project Structure
.nf
src/
  frontend/       Verilog parser and AST
  core/           Elaboration and flattening
  ir/             Intermediate representation
  codegen/        MSL and host code generation
  msl/            Metal Shading Language backend
  runtime/        Metal runtime wrapper
  utils/          Diagnostics and utilities
verilog/
  test_v1_ready_do_not_move.v  Smoke test (1 file, default run)
  test_vcd_*.v                 VCD waveform tests (12 files)
  test_repeat_dynamic.v        Dynamic repeat test
  test_real_math.v             Real math functions test
  test_wide_*.v                Wide integer tests (128-bit, 256-bit, 5+ files)
  test_system_*.v              File I/O tests (15+ files)
  pass/           Comprehensive test suite (400 files, --full flag)
  systemverilog/  SystemVerilog tests (18 files, expected to fail)
docs/
  gpga/                      Core documentation
  diff/                      REV documents (REV0-REV35 commit changelogs)
  4STATE.md                  4-state logic implementation
  gpga_4state_api.md         Complete MSL 4-state library reference
  CRLIBM_PORTING.md          CRlibm correctly rounded math port plan
  SOFTFLOAT64_IMPLEMENTATION.md  Original softfloat design (REV31)
  APP_BUNDLING.md            HDL-to-macOS apps vision
  VERILOG_REFERENCE.md       Language reference
  ASYNC_DEBUGGING.md         Async circuit debugging
  bit_packing_strategy.md    GPU memory optimization
include/
  gpga_real.h                IEEE 754 binary64 library (17,113 lines)
  gpga_real_decl.h           Forward declarations for gpga_real.h
artifacts/        Test run outputs (generated, gitignored)
.fi
.SH BUGS
Report bugs at:
.UR https://github.com/tom-johnsen/metalfpga/issues
.UE
.SH LICENSE
MetalFPGA is dual-licensed:
.TP
.B Open Source (AGPL-3.0)
Free for open-source projects, academic research, and personal use under the
GNU Affero General Public License v3.0. You must share your source code if you
distribute modified versions. If you run MetalFPGA as a network service (SaaS),
you must make your modifications available.
.TP
.B Commercial License
For proprietary/closed-source integration, commercial licenses are available.
Contact: support@tomsdata.no
.SH AUTHOR
Written by the MetalFPGA project contributors.
.SH SEE ALSO
.BR metal (1),
.BR cmake (1)
.PP
Online documentation:
.UR https://github.com/tom-johnsen/metalfpga
.UE
