.TH METALFPGA 1 "December 2025" "v0.5" "User Commands"
.SH NAME
metalfpga \- Verilog-to-Metal (MSL) compiler for GPU-based hardware simulation
.SH SYNOPSIS
.B metalfpga
.I input.v
[\fImore.v\fR ...]
[\fIOPTIONS\fR]
.SH DESCRIPTION
.B metalfpga
is a "GPGA" (GPU-based FPGA) compiler that parses and lowers a large, practical
subset of Verilog (spanning RTL and common testbench semantics) into Metal Shading
Language compute kernels. This enables FPGA designers to prototype and validate
hardware designs on Apple GPUs before synthesis to actual hardware, leveraging
massive parallelism for fast simulation.
.PP
The compiler performs the following operations:
.IP \[bu] 2
Parses Verilog RTL and testbench constructs
.IP \[bu]
Flattens module hierarchy through elaboration
.IP \[bu]
Generates Metal compute shaders for GPU execution
.IP \[bu]
Emits host-side runtime scaffolding
.PP
.B Current Status:
v0.5+ - Compiler/codegen coverage includes IEEE 754 real number arithmetic,
User-Defined Primitives (UDPs), match-3 operators (===, !==, ==?, !=?),
power operator (**), and procedural part-select assignment. Extensive support
for generate/loops, 4-state logic, signed arithmetic, system tasks, timing
controls, and switch-level primitives. 281 total test files with 93% pass rate.
.B GPU runtime execution and validation are the next milestone.
.SH OPTIONS
.TP
.BR \-\-emit\-msl " \fIPATH\fR"
Generate Metal Shading Language compute kernel and write to \fIPATH\fR.
The output file will contain GPU-executable shader code for the elaborated design.
.TP
.BR \-\-emit\-host " \fIPATH\fR"
Generate host runtime stub and write to \fIPATH\fR.
The output file will contain Objective-C++ code for interfacing with the Metal runtime.
.TP
.BR \-\-dump\-flat
Dump the flattened netlist to standard output.
Shows the elaborated design including ports, nets, assigns, and always blocks
with hierarchical-to-flat name mappings.
.TP
.BR \-\-top " \fIMODULE\fR"
Specify top-level module name.
Required when the input contains multiple module definitions.
.TP
.BR \-\-4state
Enable 4-state logic (0/1/X/Z) support.
When enabled, the compiler handles X (unknown) and Z (high-impedance) values
and their propagation through operations. Required for
.BR casex " and " casez
statements.
.TP
.BR \-\-auto
Auto-discover Verilog modules under the input file's directory tree.
Recursively searches for .v files in the same directory and subdirectories
as the input file, automatically including them in compilation.
.SH SUPPORTED VERILOG FEATURES
.SS Module System
.IP \[bu] 2
Module declarations with hierarchy and parameters
.IP \[bu]
Port declarations: input, output, inout
.IP \[bu]
Port connections (named and positional)
.IP \[bu]
Multi-file input
.IP \[bu]
Parameters and localparams with expressions
.SS Data Types
.IP \[bu] 2
Wire and reg declarations with bit-widths
.IP \[bu]
Unpacked arrays
.IP \[bu]
Memory arrays (multi-dimensional supported)
.IP \[bu]
Signed arithmetic with
.B signed
keyword
.SS Assignments
.IP \[bu] 2
Continuous assignments (assign)
.IP \[bu]
Blocking assignments (=)
.IP \[bu]
Non-blocking assignments (<=)
.SS Always Blocks
.IP \[bu] 2
Combinational (always @*)
.IP \[bu]
Sequential (always @(posedge clk), always @(negedge clk))
.IP \[bu]
Initial blocks
.SS Control Flow
.IP \[bu] 2
If/else statements
.IP \[bu]
Case statements (case, casex, casez)
.IP \[bu]
For/while/repeat loops (constant bounds, unrolled during elaboration)
.SS Generate Constructs
.IP \[bu] 2
Generate blocks with genvar
.IP \[bu]
For-generate
.IP \[bu]
If-generate
.SS Functions
.IP \[bu] 2
Functions with inputs and single return assignment
.IP \[bu]
Inlined during elaboration
.SS Operators
.IP \[bu] 2
Arithmetic: +, -, *, /, %, ** (power/exponentiation)
.IP \[bu]
Bitwise: &, |, ^, ~
.IP \[bu]
Reduction: &, |, ^, ~&, ~|, ~^
.IP \[bu]
Logical: &&, ||, !
.IP \[bu]
Shifts: <<, >>, <<<, >>>
.IP \[bu]
Comparison: ==, !=, <, >, <=, >=
.IP \[bu]
Case equality: ===, !== (exact bit-for-bit match including X/Z, requires --4state)
.IP \[bu]
Wildcard match: ==?, !=? (pattern matching with X/Z as don't-care, requires --4state)
.IP \[bu]
Ternary: ? :
.SS Bit Operations
.IP \[bu] 2
Bit selects: signal[3]
.IP \[bu]
Part selects: signal[7:0]
.IP \[bu]
Indexed part selects: signal[i +: 4], signal[i -: 4]
.IP \[bu]
Part-select assignment (procedural): data[7:0] = value, data[idx +: 4] = value
.IP \[bu]
Concatenation: {a, b, c}
.IP \[bu]
Replication: {4{1'b0}}
.SS System Functions and Tasks
.IP \[bu] 2
Type casting: $signed(...), $unsigned(...)
.IP \[bu]
Math: $clog2(...), $bits(...)
.IP \[bu]
Output: $display, $write, $strobe - Console output with format specifiers
.IP \[bu]
Monitoring: $monitor - Continuous value watching
.IP \[bu]
Control: $finish, $stop - Simulation control
.IP \[bu]
Time: $time, $stime, $realtime - Time retrieval
.IP \[bu]
Formatting: $timeformat, $printtimescale
.IP \[bu]
Memory I/O: $readmemh, $readmemb, $writememh, $writememb
.IP \[bu]
Waveform: $dumpfile, $dumpvars, $dumpall, $dumpon, $dumpoff
.IP \[bu]
String: $sformat - String formatting
.IP \[bu]
Real conversion: $itor, $rtoi, $realtobits, $bitstoreal
.SS Tasks and Time
.IP \[bu] 2
Tasks (procedural task blocks with inputs/outputs)
.IP \[bu]
time data type and time system functions
.IP \[bu]
Named events (event keyword and -> trigger)
.IP \[bu]
Timing delays (# delay syntax)
.IP \[bu]
timescale directive
.SS User-Defined Primitives (UDPs)
.IP \[bu] 2
Combinational UDPs (truth tables)
.IP \[bu]
Sequential UDPs (state machines with current/next state)
.IP \[bu]
Edge-sensitive UDPs (posedge/negedge detection)
.IP \[bu]
Level-sensitive UDPs (transparent latches)
.SS Real Number Arithmetic
.IP \[bu] 2
real data type for IEEE 754 double-precision floating-point
.IP \[bu]
Real literals: 3.14, 1.5e-10, .5, 5.
.IP \[bu]
Real arrays and parameters
.IP \[bu]
Arithmetic operators: +, -, *, /, ** (power)
.IP \[bu]
Comparison operators: <, >, <=, >=, ==, !=
.IP \[bu]
Mixed integer/real arithmetic with automatic promotion
.SS Switch-Level Modeling
.IP \[bu] 2
Transmission gates: tran, tranif0, tranif1, rtran, rtranif0, rtranif1
.IP \[bu]
MOS switches: nmos, pmos, rnmos, rpmos, cmos, rcmos
.IP \[bu]
Drive strengths: supply0, supply1, strong0, strong1, pull0, pull1, weak0, weak1, highz0, highz1
.IP \[bu]
Net types: wire, wand, wor, tri, triand, trior, tri0, tri1, supply0, supply1, trireg
.SS 4-State Logic
With
.BR \-\-4state :
.IP \[bu] 2
X/Z literals (8'bz, 4'b10zx, etc.)
.IP \[bu]
X/Z propagation in operations
.IP \[bu]
casex and casez statements
.SH ERROR DETECTION
The compiler detects and reports:
.IP \[bu] 2
Combinational loops
.IP \[bu]
Multiple drivers on regs or mixed always/assign conflicts (wire multi-drive is resolved in 4-state)
.IP \[bu]
Recursive module instantiation
.IP \[bu]
Undeclared signals
.IP \[bu]
Width mismatches (with warnings)
.SH EXAMPLES
.TP
Check syntax and elaborate design:
.B metalfpga
.I design.v
.TP
Dump flattened netlist:
.B metalfpga
.I design.v
.B \-\-dump\-flat
.TP
Generate Metal shader code:
.B metalfpga
.I design.v
.B \-\-emit\-msl
.I output.metal
.TP
Generate host runtime stub:
.B metalfpga
.I design.v
.B \-\-emit\-host
.I output.mm
.TP
Specify top module:
.B metalfpga
.I design.v
.B \-\-top
.I module_name
.TP
Enable 4-state logic:
.B metalfpga
.I design.v
.B \-\-4state
.TP
Multiple files with top specification:
.B metalfpga
.I file_a.v file_b.v
.B \-\-top
.I top
.TP
Auto-discover modules:
.B metalfpga
.I top.v
.B \-\-auto \-\-top
.I top
.TP
Full workflow example:
.B metalfpga
.I design.v
.B \-\-emit\-msl
.I design.metal
.B \-\-emit\-host
.I design.mm
.B \-\-4state
.SH EXIT STATUS
.TP
.B 0
Successful elaboration
.TP
.B 1
Parsing or elaboration error
.TP
.B 2
Invalid command-line arguments
.SH FILES
.TP
.I verilog/test_*.v
Default test suite (54 files)
.TP
.I verilog/pass/*.v
Extended test suite (227 files, requires --full flag)
.TP
.I verilog/systemverilog/*.v
SystemVerilog test suite (18 files, expected to fail)
.TP
.I docs/gpga/README.md
Project architecture and goals
.TP
.I docs/gpga/verilog_words.md
Verilog keyword implementation status
.TP
.I docs/gpga/ir_invariants.md
Flattened netlist invariants
.TP
.I 4STATE.md
4-state logic design document
.SH NOTES
.SS Test Suite Status
281 total test files with 93% pass rate on the default test suite.
Test coverage includes UDPs, real number arithmetic, match-3 operators,
part-select assignment, reduction operators, signed arithmetic, generate
blocks, 4-state logic, system tasks, switch-level modeling, memory operations,
and timing controls.
.SS Runtime Status
MSL code generation is complete and structurally sound. GPU runtime execution
and validation are in development. Features awaiting runtime verification include:
.IP \[bu] 2
Event scheduling behavior under GPU dispatch
.IP \[bu]
System tasks requiring host services ($readmemh, $display, VCD dumping)
.IP \[bu]
Timing controls (#delay) in real-time execution
.IP \[bu]
Switch-level resolution under GPU scheduling
.IP \[bu]
Non-blocking assignment scheduling semantics
.SS Not Yet Implemented
.IP \[bu] 2
Runtime kernel execution and validation (MSL generation complete, GPU dispatch pending)
.IP \[bu]
Full sensitivity list support beyond @* and @(posedge/negedge clk)
.IP \[bu]
SystemVerilog constructs (classes, interfaces, packages, assertions)
.SS Project Structure
.nf
src/
  frontend/       Verilog parser and AST
  core/           Elaboration and flattening
  ir/             Intermediate representation
  codegen/        MSL and host code generation
  msl/            Metal Shading Language backend
  runtime/        Metal runtime wrapper
  utils/          Diagnostics and utilities
verilog/
  test_*.v        Main test suite (54 files, default run)
  pass/           Extended test suite (227 files, --full flag)
  systemverilog/  SystemVerilog tests (18 files, expected to fail)
docs/
  gpga/           Core documentation
  diff/           REV documents (commit changelogs)
  4STATE.md       4-state logic implementation
artifacts/        Test run outputs (generated, gitignored)
.fi
.SH BUGS
Report bugs at:
.UR https://github.com/anthropics/metalfpga/issues
.UE
.SH LICENSE
MetalFPGA is dual-licensed:
.TP
.B Open Source (AGPL-3.0)
Free for open-source projects, academic research, and personal use under the
GNU Affero General Public License v3.0. You must share your source code if you
distribute modified versions. If you run MetalFPGA as a network service (SaaS),
you must make your modifications available.
.TP
.B Commercial License
For proprietary/closed-source integration, commercial licenses are available.
Contact: support@tomsdata.no
.SH AUTHOR
Written by the MetalFPGA project contributors.
.SH SEE ALSO
.BR metal (1),
.BR cmake (1)
.PP
Online documentation:
.UR https://github.com/anthropics/metalfpga
.UE
