# MSL ‚Üí Verilog Reverse Parser Design Document

**Project:** metalfpga Bidirectional Compilation
**Purpose:** Enable roundtrip verification (Verilog ‚Üí MSL ‚Üí Verilog) and MSL-first design workflows
**Status:** Design Proposal v1.0
**Author:** Design contemplation based on codebase analysis

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Vision & Use Cases](#vision--use-cases)
3. [Architecture Overview](#architecture-overview)
4. [Technical Foundation](#technical-foundation)
5. [Parser Design](#parser-design)
6. [Recovery Algorithms](#recovery-algorithms)
7. [Challenges & Solutions](#challenges--solutions)
8. [Implementation Roadmap](#implementation-roadmap)
9. [Advanced Applications](#advanced-applications)
10. [Testing & Validation](#testing--validation)

---

## Executive Summary

This document proposes a **reverse parser** that converts Metal Shading Language (MSL) kernels generated by metalfpga back into synthesizable Verilog RTL. This enables:

1. **Roundtrip Verification**: Verilog ‚Üí MSL ‚Üí Verilog' ‚Üí verify equivalence
2. **MSL-First Design**: Write optimized GPU compute kernels, export to ASIC/FPGA
3. **Debugging Aid**: Inspect generated MSL by converting back to familiar Verilog
4. **Cross-Platform Portability**: MSL becomes an intermediate representation

### Feasibility Assessment

**High Confidence (80-90% Recoverable):**
- Port declarations and signal names
- Combinational logic expressions
- Sequential logic (always @(posedge clk))
- Four-state logic semantics
- Array operations and bit manipulations

**Medium Confidence (50-70% Recoverable):**
- Module hierarchy (requires metadata enhancement)
- Multi-driver wire resolution
- Task/function boundaries

**Low Confidence (10-30% Recoverable):**
- Original timing/delays (collapsed during compilation)
- Instance names and hierarchy (flattened)
- Generate block structure (expanded)
- Event names (scheduler abstracted)

**Recommended Strategy**: Focus on recoverable constructs first, add metadata annotations to MSL output to improve recovery rate for complex features.

---

## Vision & Use Cases

### Use Case 1: Roundtrip Verification

**Workflow:**
```
Original Verilog (design.v)
    ‚Üì metalfpga compile
Generated MSL (design.metal)
    ‚Üì reverse parser
Recovered Verilog (design_recovered.v)
    ‚Üì formal equivalence check
Verification Report: ‚úì Semantically equivalent
```

**Benefits:**
- Validate compiler correctness
- Catch semantic bugs in codegen
- Build trust in GPU simulation fidelity

### Use Case 2: MSL-First ASIC Design (The Insanity!)

**Revolutionary Workflow:**
```
Write MSL Kernel (optimized for GPU parallelism)
    ‚Üì reverse parser
Verilog RTL (synthesizable)
    ‚Üì traditional ASIC flow
Silicon! (with GPU-optimized architecture)
```

**Why This Is Brilliant:**
- Design once in MSL (familiar to GPU programmers)
- Automatic parallelism exploration (thread groups ‚Üí pipeline stages)
- Leverage Metal compiler optimizations
- Export to any Verilog-compatible tool (Synopsys, Cadence, Xilinx, etc.)

**Example:**
```metal
// GPU kernel for image processing
kernel void image_filter(
  constant uchar* input [[buffer(0)]],
  device uchar* output [[buffer(1)]],
  uint gid [[thread_position_in_grid]]) {

  uint sum = 0;
  for (uint i = 0; i < 9; i++) {
    sum += input[gid * 9 + i];
  }
  output[gid] = (uchar)(sum / 9);
}
```

Converts to:
```verilog
module image_filter(
  input [7:0] input_0, input_1, ..., input_8,
  output [7:0] output_result
);
  wire [11:0] sum;
  assign sum = input_0 + input_1 + input_2 + input_3 +
               input_4 + input_5 + input_6 + input_7 + input_8;
  assign output_result = sum / 9;
endmodule
```

### Use Case 3: Educational Tool

**Teach Both Directions:**
- Students learn Verilog ‚Üí see equivalent MSL
- GPU programmers learn MSL ‚Üí see equivalent Verilog
- Understand hardware/software duality

### Use Case 4: IP Core Generation

**Automated IP Library:**
```
MSL Library (optimized kernels)
    ‚Üì reverse parser
Verilog IP Cores (for synthesis)
    ‚Üì commercial distribution
Reusable Hardware IP
```

---

## Architecture Overview

### High-Level Design

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    MSL ‚Üí Verilog Pipeline                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                    ‚îÇ                    ‚îÇ
        ‚ñº                    ‚ñº                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  MSL Parser  ‚îÇ    ‚îÇ  Metadata    ‚îÇ    ‚îÇ  4-State     ‚îÇ
‚îÇ              ‚îÇ    ‚îÇ  Extractor   ‚îÇ    ‚îÇ  Library     ‚îÇ
‚îÇ  (Lexer/AST) ‚îÇ    ‚îÇ  (Comments)  ‚îÇ    ‚îÇ  Reverse Map ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                   ‚îÇ                    ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               ‚îÇ  Kernel Analyzer      ‚îÇ
               ‚îÇ  - Buffer extraction  ‚îÇ
               ‚îÇ  - Signal grouping    ‚îÇ
               ‚îÇ  - Width recovery     ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               ‚îÇ  Logic Reconstructor  ‚îÇ
               ‚îÇ  - fs_* ‚Üí operators   ‚îÇ
               ‚îÇ  - Control flow       ‚îÇ
               ‚îÇ  - State detection    ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               ‚îÇ  Verilog Generator    ‚îÇ
               ‚îÇ  - Module synthesis   ‚îÇ
               ‚îÇ  - Port declarations  ‚îÇ
               ‚îÇ  - Always blocks      ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚ñº
                   Recovered Verilog
```

### Component Breakdown

#### 1. MSL Parser
- **Input**: `.metal` file
- **Output**: MSL Abstract Syntax Tree
- **Technology**:
  - Option A: Leverage Apple's Metal compiler frontend (if accessible)
  - Option B: Custom parser using ANTLR or hand-written recursive descent
  - Option C: Clang/LLVM toolchain (Metal uses LLVM IR)

#### 2. Metadata Extractor
- Parse structured comments: `// always @(posedge clk)`
- Extract module name from kernel name: `gpga_<module>` ‚Üí `<module>`
- Identify sequential vs combinational kernels

#### 3. 4-State Library Reverse Map
- `fs_add32(a, b, width)` ‚Üí `a + b`
- `fs_and32(a, b, width)` ‚Üí `a & b`
- `fs_case_eq32(a, b, width)` ‚Üí `a === b` (case equality)
- Full mapping table in Section 6

#### 4. Kernel Analyzer
- Extract buffer declarations from function signature
- Group `_val` and `_xz` pairs
- Determine signal widths from `fs_make32/64` calls
- Classify ports as input/output (from `constant`/`device`)

#### 5. Logic Reconstructor
- Pattern match MSL control flow ‚Üí Verilog control flow
- Detect state variables (assigned in `_tick` kernel)
- Rebuild expression trees from assignment chains
- Handle multi-driver resolution (`__gpga_drv_*` patterns)

#### 6. Verilog Generator
- Synthesize module declaration with ports
- Generate `always @(*)` for combinational kernels
- Generate `always @(posedge clk)` for sequential kernels
- Format output with indentation and comments

---

## Technical Foundation

### MSL Naming Conventions (What We Know)

#### Signal Name Pattern
```
Verilog Signal: my_signal [7:0]
    ‚Üì
MSL Representation:
  - my_signal_val (ulong/uint)  // Actual bit values
  - my_signal_xz  (ulong/uint)  // X/Z metadata
```

**Recovery Rule:**
```python
if var_name.endswith("_val"):
    signal_name = var_name[:-4]  # Remove "_val"
    xz_companion = signal_name + "_xz"
    if exists(xz_companion):
        width = infer_width_from_type_and_usage()
        return Signal(name=signal_name, width=width, has_xz=True)
```

#### Port Classification
```metal
// Input port (read-only)
constant uint* input_signal_val [[buffer(0)]]

// Output port (read-write)
device uint* output_signal_val [[buffer(2)]]

// Inout port (bidirectional)
device uint* inout_signal_val [[buffer(4)]]
```

**Recovery Rule:**
```python
if buffer_qualifier == "constant":
    direction = "input"
elif buffer_qualifier == "device":
    # Ambiguous: could be output or inout
    # Heuristic: if only written, then output
    direction = "output" if only_written else "inout"
```

#### Width Inference
```metal
// Explicit width in fs_make32/64 calls
FourState32 result = fs_add32(
    fs_make32(a_val[gid], a_xz[gid], 8u),  // ‚Üê width = 8
    fs_make32(b_val[gid], b_xz[gid], 8u),  // ‚Üê width = 8
    8u);  // ‚Üê result width = 8

// Type inference
uint  my_var;     // 32 bits max
ulong my_var;     // 64 bits max
```

**Recovery Rule:**
```python
def infer_width(signal_name):
    # Search for fs_make32/64(signal_name_val, signal_name_xz, WIDTH)
    for call in find_fs_make_calls(signal_name):
        return call.width_argument

    # Fallback: type-based
    if signal_type == "uint":
        return 32
    elif signal_type == "ulong":
        return 64
```

### Four-State Operation Mapping Table

| MSL Function | Verilog Operator | Notes |
|--------------|------------------|-------|
| `fs_add32(a, b, w)` | `a + b` | Arithmetic addition |
| `fs_sub32(a, b, w)` | `a - b` | Arithmetic subtraction |
| `fs_mul32(a, b, w)` | `a * b` | Multiplication |
| `fs_div32(a, b, w)` | `a / b` | Integer division |
| `fs_mod32(a, b, w)` | `a % b` | Modulo |
| `fs_pow32(a, b, w)` | `a ** b` | Power operator |
| `fs_and32(a, b, w)` | `a & b` | Bitwise AND |
| `fs_or32(a, b, w)` | `a \| b` | Bitwise OR |
| `fs_xor32(a, b, w)` | `a ^ b` | Bitwise XOR |
| `fs_not32(a, w)` | `~a` | Bitwise NOT |
| `fs_shl32(a, b, w)` | `a << b` | Shift left |
| `fs_shr32(a, b, w)` | `a >> b` | Shift right logical |
| `fs_sar32(a, b, w)` | `a >>> b` | Shift right arithmetic |
| `fs_eq32(a, b, w)` | `a == b` | Logical equality |
| `fs_ne32(a, b, w)` | `a != b` | Logical inequality |
| `fs_lt32(a, b, w)` | `a < b` | Less than |
| `fs_gt32(a, b, w)` | `a > b` | Greater than |
| `fs_le32(a, b, w)` | `a <= b` | Less or equal |
| `fs_ge32(a, b, w)` | `a >= b` | Greater or equal |
| `fs_case_eq32(a, b, w)` | `a === b` | Case equality (exact X/Z match) |
| `fs_log_and32(a, b, w)` | `a && b` | Logical AND |
| `fs_log_or32(a, b, w)` | `a \|\| b` | Logical OR |
| `fs_log_not32(a, w)` | `!a` | Logical NOT |
| `fs_red_and32(a, w)` | `&a` | Reduction AND |
| `fs_red_or32(a, w)` | `\|a` | Reduction OR |
| `fs_red_xor32(a, w)` | `^a` | Reduction XOR |
| `fs_mux32(c, t, f, w)` | `c ? t : f` | Ternary operator |

**Usage Example:**
```metal
// MSL
FourState32 result = fs_add32(
    fs_make32(a_val[gid], a_xz[gid], 8u),
    fs_make32(b_val[gid], b_xz[gid], 8u), 8u);
```

Reverse to:
```verilog
// Verilog
wire [7:0] result = a + b;
```

### Control Flow Patterns

#### If-Else Pattern
```metal
// MSL
if (condition_val[gid] != 0u) {
    output_val[gid] = then_val;
} else {
    output_val[gid] = else_val;
}
```

Reverse to:
```verilog
// Verilog
if (condition)
    output = then_expr;
else
    output = else_expr;
```

#### Case Statement Pattern
```metal
// MSL (4-state case)
if (fs_case_eq32(fs_make32(sel_val[gid], sel_xz[gid], 3u),
                 FourState32{0u, 0u}, 3u)) {
    // Case 0 body
} else if (fs_case_eq32(..., FourState32{1u, 0u}, 3u)) {
    // Case 1 body
} else {
    // Default body
}
```

Reverse to:
```verilog
// Verilog
case (sel)
    3'b000: // Case 0 body
    3'b001: // Case 1 body
    default: // Default body
endcase
```

#### Sequential Update Pattern
```metal
// MSL (in _tick kernel)
uint nb_state_val = state_val[gid];  // Capture
// ... compute new value ...
nb_state_val = new_value_val;        // Update temp
state_val[gid] = nb_state_val;       // Commit
```

Reverse to:
```verilog
// Verilog
always @(posedge clk)
    state <= new_value;
```

---

## Parser Design

### Phase 1: Lexical Analysis

**Token Types:**
```cpp
enum TokenType {
    // Keywords
    KERNEL, VOID, CONSTANT, DEVICE, UINT, ULONG, STRUCT,

    // Four-state functions
    FS_MAKE32, FS_MAKE64, FS_ADD32, FS_AND32, /* ... */,

    // Identifiers and literals
    IDENTIFIER, NUMBER, STRING,

    // Operators and punctuation
    LBRACKET, RBRACKET, LPAREN, RPAREN, LBRACE, RBRACE,
    SEMICOLON, COMMA, EQUALS, ASTERISK, AMPERSAND,

    // Attributes
    ATTR_BUFFER, ATTR_THREAD_POSITION,

    // Special
    COMMENT, NEWLINE, EOF
};
```

**Lexer Pseudocode:**
```python
class MSLLexer:
    def __init__(self, source: str):
        self.source = source
        self.pos = 0
        self.tokens = []

    def tokenize(self):
        while not at_end():
            skip_whitespace()

            if current_char() == '/':
                if peek() == '/':
                    self.tokens.append(scan_line_comment())
                elif peek() == '*':
                    self.tokens.append(scan_block_comment())
            elif current_char().isalpha():
                self.tokens.append(scan_identifier_or_keyword())
            elif current_char().isdigit():
                self.tokens.append(scan_number())
            elif current_char() in operators:
                self.tokens.append(scan_operator())
            # ... handle other cases

        return self.tokens
```

### Phase 2: Syntax Analysis (AST Construction)

**MSL AST Node Types:**
```python
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class MSLKernel:
    name: str
    parameters: List['MSLParameter']
    body: 'MSLBlock'
    is_tick_kernel: bool  # True if name ends with "_tick"

@dataclass
class MSLParameter:
    qualifier: str  # "constant", "device", or ""
    type: str       # "uint*", "ulong*", "GpgaParams&"
    name: str
    attribute: Optional[str]  # e.g., "[[buffer(0)]]"

@dataclass
class MSLBlock:
    statements: List['MSLStatement']

@dataclass
class MSLStatement:
    # Union of statement types
    kind: str  # "assign", "if", "for", "return", etc.
    # ... specific fields per kind

@dataclass
class MSLExpression:
    kind: str  # "binop", "call", "literal", "ident", etc.
    # ... specific fields per kind

@dataclass
class MSLFunctionCall:
    function_name: str
    arguments: List['MSLExpression']
```

**Parser Pseudocode:**
```python
class MSLParser:
    def __init__(self, tokens: List[Token]):
        self.tokens = tokens
        self.pos = 0

    def parse(self) -> List[MSLKernel]:
        kernels = []

        while not at_end():
            if match(KERNEL):
                kernels.append(parse_kernel())
            else:
                advance()  # Skip non-kernel declarations

        return kernels

    def parse_kernel(self) -> MSLKernel:
        expect(KERNEL)
        expect(VOID)
        name = expect(IDENTIFIER).value
        expect(LPAREN)
        parameters = parse_parameter_list()
        expect(RPAREN)
        body = parse_block()

        return MSLKernel(
            name=name,
            parameters=parameters,
            body=body,
            is_tick_kernel=name.endswith("_tick")
        )

    def parse_parameter_list(self) -> List[MSLParameter]:
        params = []

        while not check(RPAREN):
            # Parse qualifier (constant/device)
            qualifier = ""
            if match(CONSTANT, DEVICE):
                qualifier = previous().value

            # Parse type
            type_name = expect(IDENTIFIER).value
            if match(ASTERISK):
                type_name += "*"
            elif match(AMPERSAND):
                type_name += "&"

            # Parse name
            name = expect(IDENTIFIER).value

            # Parse attribute
            attribute = None
            if match(LBRACKET):
                attribute = parse_attribute()

            params.append(MSLParameter(qualifier, type_name, name, attribute))

            if not check(RPAREN):
                expect(COMMA)

        return params
```

### Phase 3: Semantic Analysis

**Extract Signal Information:**
```python
class SignalExtractor:
    def extract_signals(self, kernel: MSLKernel) -> Dict[str, Signal]:
        signals = {}

        for param in kernel.parameters:
            if not param.name.endswith("_val"):
                continue

            signal_name = param.name[:-4]  # Remove "_val"

            # Find companion _xz parameter
            xz_param = find_parameter(kernel, signal_name + "_xz")

            # Determine direction
            if param.qualifier == "constant":
                direction = "input"
            elif param.qualifier == "device":
                direction = "output"  # or inout, needs analysis

            # Infer width
            width = infer_width_from_kernel_body(kernel, signal_name)

            signals[signal_name] = Signal(
                name=signal_name,
                width=width,
                direction=direction,
                has_xz=(xz_param is not None)
            )

        return signals

def infer_width_from_kernel_body(kernel: MSLKernel, signal_name: str) -> int:
    # Search for fs_make32/64 calls with this signal
    for stmt in walk_statements(kernel.body):
        if isinstance(stmt, MSLFunctionCall):
            if stmt.function_name in ["fs_make32", "fs_make64"]:
                # fs_make32(signal_val[gid], signal_xz[gid], WIDTH)
                if signal_appears_in_args(stmt.arguments, signal_name):
                    width_arg = stmt.arguments[2]  # Third argument
                    if isinstance(width_arg, MSLLiteral):
                        return width_arg.value

    # Fallback: determine from type
    param = find_parameter(kernel, signal_name + "_val")
    if "ulong" in param.type:
        return 64
    elif "uint" in param.type:
        return 32

    return 1  # Default
```

---

## Recovery Algorithms

### Algorithm 1: Port Declaration Recovery

**Input:** MSL kernel parameter list
**Output:** Verilog port declarations

```python
def recover_port_declarations(kernel: MSLKernel) -> List[VerilogPort]:
    signals = extract_signals(kernel)
    ports = []

    for signal in signals.values():
        # Skip internal signals (no buffer attribute)
        if not has_buffer_attribute(kernel, signal.name + "_val"):
            continue

        port_type = signal.direction
        width = signal.width

        if width == 1:
            ports.append(f"{port_type} {signal.name}")
        else:
            ports.append(f"{port_type} [{width-1}:0] {signal.name}")

    return ports

# Example output:
# input [7:0] a
# input [7:0] b
# output [7:0] result
```

### Algorithm 2: Expression Tree Reconstruction

**Input:** MSL expression (nested function calls)
**Output:** Verilog expression

```python
def reconstruct_expression(expr: MSLExpression) -> str:
    if isinstance(expr, MSLLiteral):
        return str(expr.value)

    if isinstance(expr, MSLIdentifier):
        # Remove [gid] indexing and _val suffix
        name = expr.name.replace("[gid]", "")
        if name.endswith("_val"):
            name = name[:-4]
        return name

    if isinstance(expr, MSLFunctionCall):
        func_name = expr.function_name

        # Four-state operation mapping
        if func_name == "fs_add32":
            left = reconstruct_expression(expr.arguments[0])
            right = reconstruct_expression(expr.arguments[1])
            return f"({left} + {right})"

        elif func_name == "fs_and32":
            left = reconstruct_expression(expr.arguments[0])
            right = reconstruct_expression(expr.arguments[1])
            return f"({left} & {right})"

        elif func_name == "fs_make32":
            # fs_make32(val, xz, width) ‚Üí just extract the val part
            # If val is a simple identifier, return it
            val_expr = expr.arguments[0]
            return reconstruct_expression(val_expr)

        elif func_name == "fs_mux32":
            # fs_mux32(cond, true_val, false_val, width) ‚Üí (cond ? true_val : false_val)
            cond = reconstruct_expression(expr.arguments[0])
            true_val = reconstruct_expression(expr.arguments[1])
            false_val = reconstruct_expression(expr.arguments[2])
            return f"({cond} ? {true_val} : {false_val})"

        # Add more mappings...

    return "/* unknown expression */"

# Example:
# Input:  fs_add32(fs_make32(a_val[gid], a_xz[gid], 8u),
#                   fs_make32(b_val[gid], b_xz[gid], 8u), 8u)
# Output: (a + b)
```

### Algorithm 3: Control Flow Recovery

**Input:** MSL if/else chain
**Output:** Verilog case statement (if pattern detected)

```python
def recover_case_statement(if_chain: MSLIfStatement) -> Optional[VerilogCase]:
    # Detect case pattern: sequential if-else with fs_case_eq32
    cases = []
    selector = None

    current = if_chain
    while isinstance(current, MSLIfStatement):
        # Check if condition is fs_case_eq32(selector, constant, width)
        if not is_case_equality_check(current.condition):
            return None  # Not a case pattern

        sel, case_val = extract_case_info(current.condition)

        if selector is None:
            selector = sel
        elif selector != sel:
            return None  # Different selectors, not a unified case

        cases.append((case_val, current.then_branch))
        current = current.else_branch

    # Last else branch is default
    default = current if current else None

    return VerilogCase(selector=selector, cases=cases, default=default)

def is_case_equality_check(expr: MSLExpression) -> bool:
    if not isinstance(expr, MSLFunctionCall):
        return False
    return expr.function_name in ["fs_case_eq32", "fs_case_eq64"]

def extract_case_info(expr: MSLFunctionCall) -> Tuple[str, int]:
    # fs_case_eq32(fs_make32(sel_val[gid], sel_xz[gid], W),
    #              FourState32{CASE_VAL, 0u}, W)
    selector_expr = expr.arguments[0]
    case_val_expr = expr.arguments[1]

    selector = reconstruct_expression(selector_expr)

    # Extract literal value from FourState32{val, 0u}
    if isinstance(case_val_expr, MSLStructLiteral):
        case_val = case_val_expr.fields[0].value

    return (selector, case_val)

# Example output:
# case (op)
#     3'b000: result = a + b;
#     3'b001: result = a - b;
#     default: result = 8'h00;
# endcase
```

### Algorithm 4: Sequential Logic Detection

**Input:** MSL `_tick` kernel
**Output:** Verilog always @(posedge clk) block

```python
def recover_sequential_logic(tick_kernel: MSLKernel) -> VerilogAlwaysBlock:
    # Pattern: nb_<signal>_val = ...; <signal>_val[gid] = nb_<signal>_val;

    assignments = []

    for stmt in tick_kernel.body.statements:
        if not isinstance(stmt, MSLAssignment):
            continue

        target = stmt.target

        # Look for pattern: signal_val[gid] = nb_signal_val;
        if target.endswith("_val[gid]"):
            signal_name = target[:-9]  # Remove "_val[gid]"

            # Find corresponding nb_ assignment
            nb_name = "nb_" + signal_name + "_val"
            nb_assign = find_assignment_to(tick_kernel, nb_name)

            if nb_assign:
                rhs = reconstruct_expression(nb_assign.value)
                assignments.append(f"{signal_name} <= {rhs};")

    # Extract clock from comment (if present)
    clock = extract_clock_from_comment(tick_kernel) or "clk"

    return VerilogAlwaysBlock(
        sensitivity=f"posedge {clock}",
        statements=assignments
    )

# Example output:
# always @(posedge clk) begin
#     state <= next_state;
#     counter <= counter + 1;
# end
```

---

## Challenges & Solutions

### Challenge 1: Lost Hierarchy Information

**Problem:** Module instantiation hierarchy is flattened during elaboration.

**Example:**
```verilog
// Original
module top;
    dff u_dff (.q(top_q), .d(top_d), .clk(clk));
endmodule

// After flattening
module top;
    reg u_dff_q;  // Instance name lost in signal name
endmodule
```

**Solutions:**

**Option A: Metadata Injection (Recommended)**
```metal
// Enhanced MSL output with comments
kernel void gpga_top(...) {
    // GPGA_HIERARCHY: u_dff (instance of module dff)
    // GPGA_SIGNAL: u_dff_q (maps to u_dff.q)
    device uint* u_dff_q_val [[buffer(0)]];
}
```

**Option B: Heuristic Reconstruction**
- Detect signal name patterns: `<instance>_<port>`
- Group signals by common prefix
- Infer instance boundaries from naming

**Option C: Accept Limitation**
- Reverse parser outputs flat Verilog (no hierarchy)
- Document as known limitation
- Focus on functional correctness over structural fidelity

**Recommendation:** Start with Option C, add Option A incrementally.

---

### Challenge 2: Ambiguous Signal Direction (Output vs Inout)

**Problem:** Both `output` and `inout` ports map to `device` buffers.

**Example:**
```metal
device uint* signal_val [[buffer(2)]];  // Output or inout?
```

**Solutions:**

**Option A: Usage Analysis**
```python
def determine_direction(signal_name: str, kernel: MSLKernel) -> str:
    val_name = signal_name + "_val[gid]"

    reads = count_reads(kernel, val_name)
    writes = count_writes(kernel, val_name)

    if writes > 0 and reads == 0:
        return "output"  # Only written
    elif writes > 0 and reads > 0:
        return "inout"   # Both read and written
    else:
        return "input"   # Only read (shouldn't happen for device)
```

**Option B: Conservative Default**
- Assume all `device` buffers are `output`
- Add comment: `// May be inout, verify manually`

**Option C: Metadata Annotation**
```metal
// GPGA_PORT: signal direction=inout
device uint* signal_val [[buffer(2)]];
```

**Recommendation:** Use Option A (usage analysis) with fallback to Option B.

---

### Challenge 3: Width Inference Ambiguity

**Problem:** Width not always explicit in all operations.

**Example:**
```metal
uint temp_val = signal_val[gid];  // Width unknown without context
```

**Solutions:**

**Option A: Propagate from fs_make Calls**
```python
def infer_width_propagation(kernel: MSLKernel) -> Dict[str, int]:
    widths = {}

    # First pass: explicit widths from fs_make calls
    for call in find_all_calls(kernel, ["fs_make32", "fs_make64"]):
        signal = extract_signal_name(call.arguments[0])
        width = call.arguments[2].value
        widths[signal] = width

    # Second pass: propagate through assignments
    changed = True
    while changed:
        changed = False
        for assign in find_all_assignments(kernel):
            lhs_width = widths.get(assign.target)
            rhs_width = infer_width(assign.value, widths)
            if lhs_width is None and rhs_width is not None:
                widths[assign.target] = rhs_width
                changed = True

    return widths
```

**Option B: Type-Based Fallback**
- `uint` ‚Üí assume 32 bits (or less, needs refinement)
- `ulong` ‚Üí assume 64 bits (or less)

**Option C: Conservative Maximum**
- `uint` ‚Üí always output `[31:0]`
- `ulong` ‚Üí always output `[63:0]`

**Recommendation:** Use Option A with Option B as fallback.

---

### Challenge 4: Timing Information Loss

**Problem:** Delays are compiled away.

**Example:**
```verilog
// Original
#10 signal = value;

// MSL
signal_val[gid] = value_val;  // Delay lost
```

**Solutions:**

**Option A: Accept Loss**
- Document that recovered Verilog has no timing
- Suitable for functional verification only

**Option B: Scheduler Reconstruction**
- If scheduler code exists, attempt to reverse-engineer delays
- Very complex, low success rate

**Option C: Zero-Delay Annotation**
```verilog
// Recovered Verilog
signal = value;  // Original had delay, see MSL for scheduler
```

**Recommendation:** Use Option A (accept loss), add Option C (comments).

---

### Challenge 5: Real Number Representation

**Problem:** Real values stored as bit patterns.

**Example:**
```metal
ulong pi_val = 4614256656552045848ul;  // as_type<ulong>(3.14159)
```

**Solutions:**

**Option A: Reverse Conversion**
```python
def recover_real_literal(bits: int) -> float:
    # Use IEEE 754 bit pattern to float conversion
    import struct
    return struct.unpack('d', struct.pack('Q', bits))[0]

# Output: real pi = 3.14159;
```

**Option B: Detect gpga_real_to_bits Calls**
```metal
ulong x_val = gpga_real_to_bits(3.14);  // Keep original 3.14
```

**Recommendation:** Use Option B where possible, Option A as fallback.

---

### Challenge 6: Multi-Driver Resolution

**Problem:** Multiple continuous assignments to same wire require resolution.

**Example:**
```metal
// MSL
__gpga_drv_signal_0_val[gid] = expr1_val;
__gpga_drv_signal_1_val[gid] = expr2_val;
__gpga_res_signal_val[gid] = resolve(...);  // Complex resolution
```

**Solutions:**

**Option A: Detect Pattern and Reverse**
```python
def recover_multi_driver(kernel: MSLKernel) -> List[VerilogAssign]:
    drivers = {}

    for assign in find_assignments(kernel):
        if "__gpga_drv_" in assign.target:
            # Extract: __gpga_drv_<signal>_<N>_val
            parts = assign.target.split("_")
            signal = parts[2]
            driver_id = parts[3]

            if signal not in drivers:
                drivers[signal] = []
            drivers[signal].append(reconstruct_expression(assign.value))

    assigns = []
    for signal, exprs in drivers.items():
        for expr in exprs:
            assigns.append(f"assign {signal} = {expr};")

    return assigns

# Output:
# assign signal = expr1;
# assign signal = expr2;  // Verilog will handle resolution
```

**Option B: Single Assignment with Comment**
```verilog
assign signal = /* multi-driver resolved */ final_expr;
```

**Recommendation:** Use Option A (preserve all drivers).

---

## Implementation Roadmap

### Phase 1: Foundation (Weeks 1-2)

**Milestone 1.1: Lexer & Parser**
- [ ] Implement MSL lexer for kernel syntax
- [ ] Build AST for kernel declarations
- [ ] Parse function signatures (parameters, attributes)
- [ ] Parse basic statements (assignments, if/else)
- [ ] Unit tests for parser

**Milestone 1.2: Signal Extraction**
- [ ] Extract port information from parameters
- [ ] Group `_val` and `_xz` pairs
- [ ] Classify input/output/inout
- [ ] Infer signal widths from fs_make calls
- [ ] Unit tests for signal extraction

**Deliverable:** Working parser that can extract module ports from MSL kernel.

---

### Phase 2: Expression Reconstruction (Weeks 3-4)

**Milestone 2.1: Four-State Operation Mapping**
- [ ] Implement reverse mapping table for all fs_* functions
- [ ] Handle fs_add, fs_sub, fs_mul, fs_div
- [ ] Handle fs_and, fs_or, fs_xor, fs_not
- [ ] Handle fs_shl, fs_shr, fs_sar
- [ ] Handle fs_eq, fs_ne, fs_lt, fs_gt, fs_le, fs_ge
- [ ] Handle fs_case_eq (case equality)
- [ ] Handle fs_mux (ternary operator)

**Milestone 2.2: Expression Tree Walking**
- [ ] Recursive expression reconstruction
- [ ] Handle nested function calls
- [ ] Simplify fs_make32(x_val, x_xz, w) ‚Üí x
- [ ] Handle array indexing [gid] removal
- [ ] Operator precedence and parenthesization

**Deliverable:** Convert MSL expressions to Verilog expressions.

---

### Phase 3: Control Flow Recovery (Weeks 5-6)

**Milestone 3.1: If/Else Reconstruction**
- [ ] Parse MSL if statements
- [ ] Reconstruct Verilog if/else
- [ ] Handle nested if/else
- [ ] Handle four-state condition evaluation

**Milestone 3.2: Case Statement Detection**
- [ ] Detect fs_case_eq pattern in if-else chains
- [ ] Extract case selector and values
- [ ] Reconstruct case/casex/casez statements
- [ ] Handle default cases

**Milestone 3.3: Loop Recovery**
- [ ] Reconstruct for loops from MSL for loops
- [ ] Handle loop bounds and increments

**Deliverable:** Convert MSL control flow to Verilog control flow.

---

### Phase 4: Sequential Logic Recovery (Weeks 7-8)

**Milestone 4.1: Tick Kernel Analysis**
- [ ] Identify _tick kernels
- [ ] Detect nb_<signal> pattern for sequential updates
- [ ] Extract clock signal from comments
- [ ] Reconstruct always @(posedge clk) blocks

**Milestone 4.2: Non-Blocking Assignment Reconstruction**
- [ ] Map MSL assignments to Verilog non-blocking (<=)
- [ ] Distinguish blocking (=) vs non-blocking (<=)

**Deliverable:** Recover sequential always blocks.

---

### Phase 5: Verilog Code Generation (Weeks 9-10)

**Milestone 5.1: Module Generation**
- [ ] Generate module declarations
- [ ] Generate port lists (input/output/inout)
- [ ] Generate wire/reg declarations
- [ ] Generate always blocks
- [ ] Generate continuous assignments

**Milestone 5.2: Code Formatting**
- [ ] Indentation and whitespace
- [ ] Comments preservation
- [ ] Consistent naming conventions
- [ ] Code readability improvements

**Deliverable:** Generate syntactically correct Verilog output.

---

### Phase 6: Testing & Validation (Weeks 11-12)

**Milestone 6.1: Unit Tests**
- [ ] Test suite for parser
- [ ] Test suite for expression reconstruction
- [ ] Test suite for control flow recovery
- [ ] Test suite for sequential logic recovery

**Milestone 6.2: End-to-End Tests**
- [ ] Simple combinational circuits (adder, mux)
- [ ] Sequential circuits (counter, shift register)
- [ ] Complex designs (ALU, state machines)

**Milestone 6.3: Roundtrip Verification**
- [ ] Verilog ‚Üí MSL ‚Üí Verilog ‚Üí compare
- [ ] Functional equivalence checking (using formal tools)
- [ ] Identify semantic preservation rate

**Deliverable:** Validated reverse parser with test coverage >80%.

---

### Phase 7: Advanced Features (Weeks 13-16)

**Milestone 7.1: Multi-Driver Resolution**
- [ ] Detect __gpga_drv_ patterns
- [ ] Reconstruct multiple continuous assignments
- [ ] Handle drive strength information

**Milestone 7.2: Metadata Enhancement**
- [ ] Modify msl_codegen.cc to emit metadata comments
- [ ] Preserve hierarchy information
- [ ] Add signal mapping annotations

**Milestone 7.3: Real Number Support**
- [ ] Reverse IEEE 754 bit patterns to floating point
- [ ] Detect gpga_real_to_bits/gpga_bits_to_real calls
- [ ] Generate real declarations

**Deliverable:** Handle complex Verilog features.

---

### Phase 8: MSL-First Design Flow (Weeks 17-20)

**Milestone 8.1: MSL Design Templates**
- [ ] Create library of MSL design patterns
- [ ] Document MSL ‚Üí Verilog best practices
- [ ] Provide example MSL-first designs

**Milestone 8.2: Synthesis Flow Integration**
- [ ] Test recovered Verilog with synthesis tools (Yosys, Synopsys)
- [ ] Validate FPGA implementation (Xilinx, Intel)
- [ ] Verify ASIC flow compatibility

**Milestone 8.3: Documentation**
- [ ] User guide for reverse parser
- [ ] MSL-first design methodology
- [ ] Case studies and examples

**Deliverable:** Production-ready MSL-first design flow.

---

## Advanced Applications

### Application 1: Automatic Hardware/Software Co-Design

**Vision:**
```
Write Once in MSL
    ‚îú‚îÄ Deploy to GPU ‚Üí Immediate simulation/validation
    ‚îú‚îÄ Deploy to FPGA ‚Üí Rapid prototyping via reverse parser
    ‚îî‚îÄ Deploy to ASIC ‚Üí Final product via reverse parser
```

**Workflow:**
```metal
// 1. Write MSL kernel (GPU-optimized)
kernel void image_filter(constant uchar* in [[buffer(0)]],
                         device uchar* out [[buffer(1)]],
                         uint gid [[thread_position_in_grid]]) {
    // GPU computation
}
```

‚Üì Deploy to GPU (native)

‚Üì Reverse parse to Verilog

```verilog
// 2. Generated Verilog (FPGA/ASIC-ready)
module image_filter(
    input [7:0] in,
    output [7:0] out
);
    // Synthesizable RTL
endmodule
```

‚Üì Synthesize with standard tools

**Benefits:**
- Single source of truth (MSL)
- Parallel development (GPU sim + hardware design)
- Reduced design time (no manual RTL rewrite)

---

### Application 2: IP Core Generation from Metal Compute

**Scenario:** You have optimized Metal compute shaders for ML/DSP.

**Process:**
1. Write highly optimized Metal kernel for specific algorithm
2. Reverse parse to Verilog
3. Package as IP core for licensing/distribution
4. Customers integrate into FPGA/ASIC without knowing original MSL

**Example - FFT Accelerator:**
```metal
// Optimized FFT in Metal
kernel void fft_butterfly(...) {
    // Complex Cooley-Tukey algorithm
    // Highly optimized for GPU parallelism
}
```

‚Üì Reverse parser

```verilog
// Verilog IP Core
module fft_accelerator #(
    parameter N = 1024
)(
    input clk,
    input [15:0] data_in_re, data_in_im,
    output [15:0] data_out_re, data_out_im
);
    // Auto-generated pipelined FFT
endmodule
```

**Market Opportunity:**
- Sell GPU-optimized algorithms as hardware IP
- Dual licensing: software (MSL) + hardware (Verilog)
- Unified development reduces cost

---

### Application 3: Formal Verification of Compiler

**Goal:** Prove that metalfpga codegen is semantically correct.

**Method:**
```
Original Verilog (V1)
    ‚Üì metalfpga compile
Generated MSL (M)
    ‚Üì reverse parse
Recovered Verilog (V2)
    ‚Üì formal equivalence check
V1 ‚â° V2? ‚Üí Verify compiler correctness
```

**Tools:**
- **Yosys**: Open-source synthesis with equivalence checking
- **SymbiYosys**: Formal verification frontend for Yosys
- **ABC**: Logic synthesis and verification
- **Commercial**: Synopsys Formality, Cadence Conformal

**Test Harness:**
```python
def test_compiler_correctness(verilog_file):
    # Step 1: Compile to MSL
    msl_file = metalfpga_compile(verilog_file)

    # Step 2: Reverse parse
    recovered_verilog = reverse_parse_msl(msl_file)

    # Step 3: Formal equivalence check
    result = yosys_equiv_check(verilog_file, recovered_verilog)

    assert result.equivalent, "Compiler bug detected!"
```

**Continuous Integration:**
- Run on all 228+ test cases
- Catch codegen regressions immediately
- Build confidence in simulation results

---

### Application 4: Educational Platform

**Course: "Hardware/Software Duality"**

**Module 1: Verilog ‚Üí MSL**
- Show how RTL maps to GPU kernels
- Explain parallelism in hardware vs GPU

**Module 2: MSL ‚Üí Verilog**
- Teach GPU programmers to think in hardware
- Understand synthesis constraints from GPU perspective

**Module 3: Optimizing Both Ways**
- Write efficient Verilog ‚Üí see GPU kernel
- Write efficient MSL ‚Üí see RTL implications

**Lab Exercises:**
```
Lab 1: Design a simple ALU in Verilog
    ‚Üí Compile to MSL
    ‚Üí Observe GPU parallelization
    ‚Üí Run simulation on GPU
    ‚Üí Reverse parse back to Verilog
    ‚Üí Compare before/after

Lab 2: Write image filter in MSL
    ‚Üí Reverse parse to Verilog
    ‚Üí Synthesize to FPGA
    ‚Üí Compare GPU vs FPGA performance
    ‚Üí Understand area/speed tradeoffs
```

---

## Testing & Validation

### Test Strategy

#### Level 1: Unit Tests (Component-Level)

**Parser Tests:**
```python
def test_parse_kernel_signature():
    msl = """
    kernel void gpga_test(
        constant uint* a_val [[buffer(0)]],
        device uint* b_val [[buffer(1)]],
        uint gid [[thread_position_in_grid]]) {
    }
    """
    kernel = parse_msl(msl)
    assert kernel.name == "gpga_test"
    assert len(kernel.parameters) == 3
    assert kernel.parameters[0].qualifier == "constant"

def test_expression_reconstruction():
    msl_expr = parse_expr("fs_add32(a, b, 8u)")
    verilog_expr = reconstruct_expression(msl_expr)
    assert verilog_expr == "(a + b)"
```

**Signal Extraction Tests:**
```python
def test_signal_width_inference():
    msl = """
    kernel void gpga_test(...) {
        FourState32 x = fs_make32(a_val[gid], a_xz[gid], 8u);
    }
    """
    signals = extract_signals(parse_msl(msl))
    assert signals['a'].width == 8
```

---

#### Level 2: Integration Tests (End-to-End)

**Simple Combinational:**
```python
def test_roundtrip_simple_adder():
    original = """
    module adder(
        input [7:0] a, b,
        output [7:0] sum
    );
        assign sum = a + b;
    endmodule
    """

    msl = metalfpga_compile(original)
    recovered = reverse_parse(msl)

    assert functionally_equivalent(original, recovered)
```

**Sequential Logic:**
```python
def test_roundtrip_counter():
    original = """
    module counter(
        input clk, reset,
        output reg [7:0] count
    );
        always @(posedge clk)
            if (reset)
                count <= 8'h00;
            else
                count <= count + 1;
    endmodule
    """

    msl = metalfpga_compile(original, flags=["--4state"])
    recovered = reverse_parse(msl)

    assert functionally_equivalent(original, recovered)
```

**Complex Control Flow:**
```python
def test_roundtrip_alu():
    # Use test_simple_alu.v from verilog/ directory
    original = read_file("verilog/test_simple_alu.v")

    msl = metalfpga_compile(original, flags=["--4state"])
    recovered = reverse_parse(msl)

    # Check case statement reconstruction
    assert "case" in recovered
    assert "3'b000" in recovered  # Case values preserved
```

---

#### Level 3: Formal Verification

**Equivalence Checking:**
```bash
#!/bin/bash
# equiv_check.sh

# Compile original to gate-level
yosys -p "read_verilog original.v; synth; write_verilog original_synth.v"

# Compile recovered to gate-level
yosys -p "read_verilog recovered.v; synth; write_verilog recovered_synth.v"

# Equivalence check
yosys -p "
    read_verilog original_synth.v
    rename original recovered_orig
    read_verilog recovered_synth.v
    equiv_make recovered_orig recovered equiv
    equiv_simple
    equiv_status -assert
"
```

**Property Checking:**
```python
# Use SymbiYosys for property verification
def test_property_preservation():
    original = """
    module counter(...);
        // Property: count never exceeds max
        assert property (@(posedge clk) count <= 8'hFF);
    endmodule
    """

    # Compile and reverse
    recovered = roundtrip(original)

    # Verify property holds in both
    assert verify_property(original, "count <= 8'hFF")
    assert verify_property(recovered, "count <= 8'hFF")
```

---

### Success Metrics

**Metric 1: Syntactic Correctness**
- Target: 100% of recovered Verilog must parse without errors
- Tool: iverilog, Verilator for syntax checking

**Metric 2: Semantic Equivalence**
- Target: >95% functional equivalence for RTL-only designs
- Tool: Yosys equivalence checking, formal verification

**Metric 3: Synthesis Success Rate**
- Target: >90% of recovered Verilog synthesizes without errors
- Tool: Yosys, Synopsys Design Compiler

**Metric 4: Test Coverage**
- Target: Pass all 228 existing metalfpga test cases
- Measure: Roundtrip success rate

**Metric 5: Complexity Handling**
- Target: Handle designs up to 10K lines of Verilog
- Measure: Performance benchmarks

---

## Conclusion

The MSL ‚Üí Verilog reverse parser is **highly feasible** with the following characteristics:

### ‚úÖ High Confidence Areas
- Port and signal recovery (90%+ accuracy expected)
- Expression reconstruction (85%+ accuracy)
- Control flow recovery (80%+ for combinational logic)
- Sequential logic detection (75%+ accuracy)

### ‚ö†Ô∏è Medium Confidence Areas
- Module hierarchy recovery (requires metadata enhancement)
- Multi-driver wire resolution (pattern detection needed)
- Width inference (needs sophisticated analysis)

### ‚ùå Known Limitations
- Timing information lost (accept as constraint)
- Instance names lost (flat Verilog output)
- Generate structure lost (expanded output)
- Task/function boundaries (inlined)

### üöÄ Revolutionary Potential

**MSL-First Design Flow enables:**
1. Write hardware in Metal (GPU-native language)
2. Simulate on GPU (massive parallelism)
3. Export to Verilog (ASIC/FPGA compatibility)
4. **Single source ‚Üí multiple targets**

This creates a **unified hardware/software design paradigm** where:
- GPU programmers can design ASICs
- Hardware engineers can leverage GPU tooling
- Both communities benefit from bidirectional translation

### Next Steps

1. **Implement Phase 1-2** (Foundation + Expression Recovery)
2. **Validate on Simple Tests** (adder, mux, counter)
3. **Add Metadata to MSL Codegen** (enhance reversibility)
4. **Build to Production** (handle 228 test cases)
5. **Document MSL-First Methodology** (pioneer new workflow)

**This is not just a reverse parser‚Äîit's a paradigm shift in hardware design.**

---

*End of Design Document*
