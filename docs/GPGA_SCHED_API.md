# GPGA Scheduler API Documentation

## Overview

The `gpga_sched.h` header provides a comprehensive scheduling infrastructure for Verilog/SystemVerilog simulation in Metal Shading Language (MSL). This library implements the IEEE 1364/1800 event-driven simulation semantics, including process scheduling, timing control, event handling, non-blocking assignments, and system task services.

**Key Features:**
- IEEE-compliant event-driven simulation scheduler
- Support for all Verilog timing controls (delay, event, edge-sensitive)
- Non-blocking assignment (NBA) scheduling with delta cycles
- Process lifecycle management (fork/join semantics)
- System task/function service infrastructure ($display, $monitor, file I/O, etc.)
- Edge-sensitive event detection (posedge, negedge, any)
- Repeat and delay loop support
- VCD dump control integration
- Macro-based code generation for compile-time configuration

**Implementation Strategy:**
The library uses C preprocessor macros to generate type-safe, compile-time configured scheduler structures. All array sizes and counts are determined at compile time based on static analysis of the Verilog source code.

---

## Table of Contents

1. [Core Data Structures](#core-data-structures)
2. [Scheduler Constants](#scheduler-constants)
3. [Wait Type Constants](#wait-type-constants)
4. [Edge Type Constants](#edge-type-constants)
5. [Process State Constants](#process-state-constants)
6. [Scheduler Phase Constants](#scheduler-phase-constants)
7. [Scheduler Status Constants](#scheduler-status-constants)
8. [Scheduler Flag Constants](#scheduler-flag-constants)
9. [Service Infrastructure](#service-infrastructure)
10. [Service Argument Types](#service-argument-types)
11. [Service Kind Constants](#service-kind-constants)
12. [Code Generation Macros](#code-generation-macros)
13. [Usage Examples](#usage-examples)

---

## Core Data Structures

### `GpgaSchedParams`

```cpp
struct GpgaSchedParams {
    uint count;
    uint max_steps;
    uint max_proc_steps;
    uint service_capacity;
};
```

**Description**: Runtime parameters for scheduler execution control.

**Fields**:
- `count`: Number of time steps or simulation iterations to execute
- `max_steps`: Maximum total scheduler steps before timeout
- `max_proc_steps`: Maximum steps per process before yielding
- `service_capacity`: Maximum number of service records per time step

**Usage**: Passed to the scheduler kernel to control simulation bounds and prevent infinite loops.

---

### `GpgaServiceRecord` (Simple)

```cpp
struct GpgaServiceRecord {
    uint kind;
    uint pid;
    uint format_id;
    uint arg_count;
    uint arg_kind[GPGA_SCHED_SERVICE_MAX_ARGS];
    uint arg_width[GPGA_SCHED_SERVICE_MAX_ARGS];
    ulong arg_val[GPGA_SCHED_SERVICE_MAX_ARGS];
    ulong arg_xz[GPGA_SCHED_SERVICE_MAX_ARGS];
};
```

**Description**: Represents a system task/function call (e.g., `$display`, `$monitor`) for values ≤64 bits.

**Fields**:
- `kind`: Service type (see [Service Kind Constants](#service-kind-constants))
- `pid`: Process ID that requested the service
- `format_id`: Index into format string table
- `arg_count`: Number of arguments (0 to `GPGA_SCHED_SERVICE_MAX_ARGS`)
- `arg_kind`: Array of argument type identifiers (value, ident, string, real, wide)
- `arg_width`: Bit width of each argument
- `arg_val`: Argument values (lower 64 bits)
- `arg_xz`: Four-state unknown/high-Z markers for each argument

**Generated By**: `GPGA_SCHED_DEFINE_SERVICE_RECORD_SIMPLE()`

---

### `GpgaServiceRecord` (Wide)

```cpp
struct GpgaServiceRecord {
    uint kind;
    uint pid;
    uint format_id;
    uint arg_count;
    uint arg_kind[GPGA_SCHED_SERVICE_MAX_ARGS];
    uint arg_width[GPGA_SCHED_SERVICE_MAX_ARGS];
    ulong arg_val[GPGA_SCHED_SERVICE_MAX_ARGS];
    ulong arg_xz[GPGA_SCHED_SERVICE_MAX_ARGS];
    ulong arg_wide_val[GPGA_SCHED_SERVICE_MAX_ARGS * GPGA_SCHED_SERVICE_WIDE_WORDS];
    ulong arg_wide_xz[GPGA_SCHED_SERVICE_MAX_ARGS * GPGA_SCHED_SERVICE_WIDE_WORDS];
};
```

**Description**: Extended service record supporting arguments wider than 64 bits.

**Additional Fields**:
- `arg_wide_val`: Extended storage for wide integer values
- `arg_wide_xz`: Extended storage for wide integer unknown/high-Z markers

**Notes**: Used when the design contains system task arguments wider than 64 bits. The wide arrays store additional 64-bit words for each argument.

**Generated By**: `GPGA_SCHED_DEFINE_SERVICE_RECORD_WIDE()`

---

## Scheduler Constants

### `GPGA_SCHED_NO_PARENT`

```cpp
constant constexpr uint GPGA_SCHED_NO_PARENT = 0xFFFFFFFFu;
```

**Description**: Sentinel value indicating a process has no parent (is a root/initial block).

**Usage**: Used in the `gpga_proc_parent` array to identify top-level processes.

---

## Wait Type Constants

Processes can be blocked waiting for various conditions. These constants identify the wait type.

### `GPGA_SCHED_WAIT_NONE`

```cpp
constant constexpr uint GPGA_SCHED_WAIT_NONE = 0u;
```

**Description**: Process is not waiting; it is ready to execute.

---

### `GPGA_SCHED_WAIT_TIME`

```cpp
constant constexpr uint GPGA_SCHED_WAIT_TIME = 1u;
```

**Description**: Process is waiting for absolute simulation time (e.g., `#10;` delay).

**Semantics**: Process resumes when simulation time reaches the target time.

---

### `GPGA_SCHED_WAIT_EVENT`

```cpp
constant constexpr uint GPGA_SCHED_WAIT_EVENT = 2u;
```

**Description**: Process is waiting for an event trigger (e.g., `@(event_name)`).

**Semantics**: Process resumes when the specified event is triggered via `->`.

---

### `GPGA_SCHED_WAIT_COND`

```cpp
constant constexpr uint GPGA_SCHED_WAIT_COND = 3u;
```

**Description**: Process is waiting for a condition to become true (e.g., `wait(condition)`).

**Semantics**: Condition is re-evaluated each simulation step.

---

### `GPGA_SCHED_WAIT_JOIN`

```cpp
constant constexpr uint GPGA_SCHED_WAIT_JOIN = 4u;
```

**Description**: Process is waiting for child processes to complete (fork/join semantics).

**Semantics**: Parent process resumes when all children with matching join tag have completed.

---

### `GPGA_SCHED_WAIT_DELTA`

```cpp
constant constexpr uint GPGA_SCHED_WAIT_DELTA = 5u;
```

**Description**: Process is waiting for a delta cycle (zero-time delay for scheduling order).

**Semantics**: Resumes in the next delta iteration at the same simulation time.

---

### `GPGA_SCHED_WAIT_EDGE`

```cpp
constant constexpr uint GPGA_SCHED_WAIT_EDGE = 6u;
```

**Description**: Process is waiting for edge-sensitive event (posedge/negedge).

**Semantics**: Process resumes when monitored signal(s) have the specified edge transition.

---

### `GPGA_SCHED_WAIT_SERVICE`

```cpp
constant constexpr uint GPGA_SCHED_WAIT_SERVICE = 7u;
```

**Description**: Process is waiting for a service request to be fulfilled (e.g., `$readmemh`).

**Semantics**: Process is blocked until the host runtime completes the service request.

---

## Edge Type Constants

Edge-sensitive constructs can trigger on different signal transitions.

### `GPGA_SCHED_EDGE_ANY`

```cpp
constant constexpr uint GPGA_SCHED_EDGE_ANY = 0u;
```

**Description**: Trigger on any change in signal value.

**Verilog Equivalent**: `@(signal)` or `@*`

---

### `GPGA_SCHED_EDGE_POSEDGE`

```cpp
constant constexpr uint GPGA_SCHED_EDGE_POSEDGE = 1u;
```

**Description**: Trigger on positive edge (0 → 1 transition).

**Verilog Equivalent**: `@(posedge signal)`

---

### `GPGA_SCHED_EDGE_NEGEDGE`

```cpp
constant constexpr uint GPGA_SCHED_EDGE_NEGEDGE = 2u;
```

**Description**: Trigger on negative edge (1 → 0 transition).

**Verilog Equivalent**: `@(negedge signal)`

---

### `GPGA_SCHED_EDGE_LIST`

```cpp
constant constexpr uint GPGA_SCHED_EDGE_LIST = 3u;
```

**Description**: Trigger on any change in a sensitivity list (e.g., `@(a or b or c)`).

**Notes**: The scheduler tracks all signals in the list and triggers when any changes.

---

## Process State Constants

Each process has a runtime state.

### `GPGA_SCHED_PROC_READY`

```cpp
constant constexpr uint GPGA_SCHED_PROC_READY = 0u;
```

**Description**: Process is ready to execute in the current scheduler phase.

---

### `GPGA_SCHED_PROC_BLOCKED`

```cpp
constant constexpr uint GPGA_SCHED_PROC_BLOCKED = 1u;
```

**Description**: Process is blocked waiting for time, event, or condition.

---

### `GPGA_SCHED_PROC_DONE`

```cpp
constant constexpr uint GPGA_SCHED_PROC_DONE = 2u;
```

**Description**: Process has completed execution and will not resume.

---

## Scheduler Phase Constants

The IEEE 1364 event queue has distinct phases.

### `GPGA_SCHED_PHASE_ACTIVE`

```cpp
constant constexpr uint GPGA_SCHED_PHASE_ACTIVE = 0u;
```

**Description**: Active phase - blocking assignments, continuous assignments, and `$display` execute.

**Semantics**: This is the primary execution phase for procedural code.

---

### `GPGA_SCHED_PHASE_NBA`

```cpp
constant constexpr uint GPGA_SCHED_PHASE_NBA = 1u;
```

**Description**: Non-blocking assignment (NBA) update phase.

**Semantics**: All `<=` assignments scheduled in the active phase are applied. This ensures race-free concurrent updates.

---

## Scheduler Status Constants

The overall scheduler state.

### `GPGA_SCHED_STATUS_RUNNING`

```cpp
constant constexpr uint GPGA_SCHED_STATUS_RUNNING = 0u;
```

**Description**: Scheduler is actively executing simulation steps.

---

### `GPGA_SCHED_STATUS_IDLE`

```cpp
constant constexpr uint GPGA_SCHED_STATUS_IDLE = 1u;
```

**Description**: No processes are ready; waiting for time to advance or events.

---

### `GPGA_SCHED_STATUS_FINISHED`

```cpp
constant constexpr uint GPGA_SCHED_STATUS_FINISHED = 2u;
```

**Description**: All processes have completed or simulation limit reached.

---

### `GPGA_SCHED_STATUS_ERROR`

```cpp
constant constexpr uint GPGA_SCHED_STATUS_ERROR = 3u;
```

**Description**: Scheduler encountered an error (e.g., exceeded max steps).

---

### `GPGA_SCHED_STATUS_STOPPED`

```cpp
constant constexpr uint GPGA_SCHED_STATUS_STOPPED = 4u;
```

**Description**: Simulation stopped due to `$stop` or `$finish` system task.

---

## Scheduler Flag Constants

Flags control scheduler behavior and track initialization state.

### `GPGA_SCHED_FLAG_INITIALIZED`

```cpp
constant constexpr uint GPGA_SCHED_FLAG_INITIALIZED = 1u;
```

**Description**: Flag indicating scheduler data structures have been initialized.

---

### `GPGA_SCHED_FLAG_ACTIVE_INIT`

```cpp
constant constexpr uint GPGA_SCHED_FLAG_ACTIVE_INIT = 2u;
```

**Description**: Flag indicating initial/always blocks are being initialized.

**Semantics**: Set during time-zero initialization phase.

---

## Service Infrastructure

### Service ID Constants

### `GPGA_SERVICE_INVALID_ID`

```cpp
constant constexpr uint GPGA_SERVICE_INVALID_ID = 0xFFFFFFFFu;
```

**Description**: Sentinel value for invalid or uninitialized service record IDs.

---

## Service Argument Types

### `GPGA_SERVICE_ARG_VALUE`

```cpp
constant constexpr uint GPGA_SERVICE_ARG_VALUE = 0u;
```

**Description**: Argument is a numeric value (integer).

---

### `GPGA_SERVICE_ARG_IDENT`

```cpp
constant constexpr uint GPGA_SERVICE_ARG_IDENT = 1u;
```

**Description**: Argument is an identifier/hierarchical name (for VCD, monitoring).

---

### `GPGA_SERVICE_ARG_STRING`

```cpp
constant constexpr uint GPGA_SERVICE_ARG_STRING = 2u;
```

**Description**: Argument is a string literal or string index.

---

### `GPGA_SERVICE_ARG_REAL`

```cpp
constant constexpr uint GPGA_SERVICE_ARG_REAL = 3u;
```

**Description**: Argument is a real (floating-point) value.

---

### `GPGA_SERVICE_ARG_WIDE`

```cpp
constant constexpr uint GPGA_SERVICE_ARG_WIDE = 4u;
```

**Description**: Argument is a wide integer (>64 bits), stored in extended arrays.

---

## Service Kind Constants

These constants identify system task/function types.

### Display and Monitoring

### `GPGA_SERVICE_KIND_DISPLAY`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_DISPLAY = 0u;
```

**Description**: `$display` - formatted output with newline.

**Verilog**: `$display("format", args...);`

---

### `GPGA_SERVICE_KIND_MONITOR`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_MONITOR = 1u;
```

**Description**: `$monitor` - continuous monitoring with automatic printing on change.

**Verilog**: `$monitor("format", args...);`

---

### `GPGA_SERVICE_KIND_STROBE`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_STROBE = 8u;
```

**Description**: `$strobe` - formatted output at end of current time step.

**Verilog**: `$strobe("format", args...);`

**Notes**: Executes after all NBAs for the current time.

---

### `GPGA_SERVICE_KIND_WRITE`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_WRITE = 32u;
```

**Description**: `$write` - formatted output without newline.

**Verilog**: `$write("format", args...);`

---

### Simulation Control

### `GPGA_SERVICE_KIND_FINISH`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FINISH = 2u;
```

**Description**: `$finish` - terminate simulation normally.

**Verilog**: `$finish;` or `$finish(n);`

---

### `GPGA_SERVICE_KIND_STOP`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_STOP = 7u;
```

**Description**: `$stop` - pause simulation (enter interactive mode if supported).

**Verilog**: `$stop;` or `$stop(n);`

---

### VCD (Value Change Dump) Control

### `GPGA_SERVICE_KIND_DUMPFILE`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_DUMPFILE = 3u;
```

**Description**: `$dumpfile` - specify VCD output filename.

**Verilog**: `$dumpfile("filename.vcd");`

---

### `GPGA_SERVICE_KIND_DUMPVARS`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_DUMPVARS = 4u;
```

**Description**: `$dumpvars` - specify variables/scopes to dump.

**Verilog**: `$dumpvars(levels, module);`

---

### `GPGA_SERVICE_KIND_DUMPOFF`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_DUMPOFF = 9u;
```

**Description**: `$dumpoff` - suspend VCD dumping.

**Verilog**: `$dumpoff;`

---

### `GPGA_SERVICE_KIND_DUMPON`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_DUMPON = 10u;
```

**Description**: `$dumpon` - resume VCD dumping.

**Verilog**: `$dumpon;`

---

### `GPGA_SERVICE_KIND_DUMPFLUSH`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_DUMPFLUSH = 11u;
```

**Description**: `$dumpflush` - flush VCD buffer to disk.

**Verilog**: `$dumpflush;`

---

### `GPGA_SERVICE_KIND_DUMPALL`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_DUMPALL = 12u;
```

**Description**: `$dumpall` - dump all current variable values.

**Verilog**: `$dumpall;`

---

### `GPGA_SERVICE_KIND_DUMPLIMIT`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_DUMPLIMIT = 13u;
```

**Description**: `$dumplimit` - set VCD file size limit.

**Verilog**: `$dumplimit(size);`

---

### Memory Initialization

### `GPGA_SERVICE_KIND_READMEMH`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_READMEMH = 5u;
```

**Description**: `$readmemh` - read memory from hex file.

**Verilog**: `$readmemh("file.hex", memory_array);`

---

### `GPGA_SERVICE_KIND_READMEMB`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_READMEMB = 6u;
```

**Description**: `$readmemb` - read memory from binary file.

**Verilog**: `$readmemb("file.bin", memory_array);`

---

### `GPGA_SERVICE_KIND_WRITEMEMH`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_WRITEMEMH = 25u;
```

**Description**: `$writememh` - write memory to hex file.

**Verilog**: `$writememh("file.hex", memory_array);`

---

### `GPGA_SERVICE_KIND_WRITEMEMB`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_WRITEMEMB = 26u;
```

**Description**: `$writememb` - write memory to binary file.

**Verilog**: `$writememb("file.bin", memory_array);`

---

### File I/O

### `GPGA_SERVICE_KIND_FOPEN`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FOPEN = 16u;
```

**Description**: `$fopen` - open file and return file descriptor.

**Verilog**: `fd = $fopen("filename", "mode");`

---

### `GPGA_SERVICE_KIND_FCLOSE`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FCLOSE = 17u;
```

**Description**: `$fclose` - close file descriptor.

**Verilog**: `$fclose(fd);`

---

### `GPGA_SERVICE_KIND_FWRITE`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FWRITE = 14u;
```

**Description**: `$fwrite` - formatted write to file without newline.

**Verilog**: `$fwrite(fd, "format", args...);`

---

### `GPGA_SERVICE_KIND_FDISPLAY`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FDISPLAY = 15u;
```

**Description**: `$fdisplay` - formatted write to file with newline.

**Verilog**: `$fdisplay(fd, "format", args...);`

---

### `GPGA_SERVICE_KIND_FGETC`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FGETC = 18u;
```

**Description**: `$fgetc` - read single character from file.

**Verilog**: `c = $fgetc(fd);`

---

### `GPGA_SERVICE_KIND_FGETS`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FGETS = 19u;
```

**Description**: `$fgets` - read line from file into string.

**Verilog**: `$fgets(str, fd);`

---

### `GPGA_SERVICE_KIND_FEOF`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FEOF = 20u;
```

**Description**: `$feof` - test for end-of-file.

**Verilog**: `eof = $feof(fd);`

---

### `GPGA_SERVICE_KIND_FSCANF`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FSCANF = 21u;
```

**Description**: `$fscanf` - formatted read from file.

**Verilog**: `n = $fscanf(fd, "format", args...);`

---

### `GPGA_SERVICE_KIND_SSCANF`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_SSCANF = 22u;
```

**Description**: `$sscanf` - formatted read from string.

**Verilog**: `n = $sscanf(str, "format", args...);`

---

### `GPGA_SERVICE_KIND_FTELL`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FTELL = 23u;
```

**Description**: `$ftell` - get current file position.

**Verilog**: `pos = $ftell(fd);`

---

### `GPGA_SERVICE_KIND_FSEEK`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FSEEK = 27u;
```

**Description**: `$fseek` - set file position.

**Verilog**: `$fseek(fd, offset, operation);`

---

### `GPGA_SERVICE_KIND_REWIND`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_REWIND = 24u;
```

**Description**: `$rewind` - rewind file to beginning.

**Verilog**: `$rewind(fd);`

---

### `GPGA_SERVICE_KIND_FFLUSH`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FFLUSH = 28u;
```

**Description**: `$fflush` - flush file output buffer.

**Verilog**: `$fflush(fd);`

---

### `GPGA_SERVICE_KIND_FERROR`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FERROR = 29u;
```

**Description**: `$ferror` - get file error status.

**Verilog**: `err = $ferror(fd, str);`

---

### `GPGA_SERVICE_KIND_FREAD`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FREAD = 31u;
```

**Description**: `$fread` - read binary data from file.

**Verilog**: `n = $fread(mem, fd);`

---

### `GPGA_SERVICE_KIND_FUNGETC`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_FUNGETC = 30u;
```

**Description**: `$fungetc` - push character back to file stream.

**Verilog**: `$fungetc(c, fd);`

---

### Formatting and Configuration

### `GPGA_SERVICE_KIND_SFORMAT`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_SFORMAT = 33u;
```

**Description**: `$sformat` - format string into variable.

**Verilog**: `$sformat(str, "format", args...);`

---

### `GPGA_SERVICE_KIND_TIMEFORMAT`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_TIMEFORMAT = 34u;
```

**Description**: `$timeformat` - configure time display format.

**Verilog**: `$timeformat(units, precision, suffix, width);`

---

### `GPGA_SERVICE_KIND_PRINTTIMESCALE`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_PRINTTIMESCALE = 35u;
```

**Description**: `$printtimescale` - print module timescale.

**Verilog**: `$printtimescale(module);`

---

### Command-Line Arguments

### `GPGA_SERVICE_KIND_TESTPLUSARGS`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_TESTPLUSARGS = 36u;
```

**Description**: `$test$plusargs` - test for command-line argument.

**Verilog**: `if ($test$plusargs("DEBUG")) ...`

---

### `GPGA_SERVICE_KIND_VALUEPLUSARGS`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_VALUEPLUSARGS = 37u;
```

**Description**: `$value$plusargs` - retrieve command-line argument value.

**Verilog**: `$value$plusargs("TIMEOUT=%d", timeout);`

---

### PLA System Tasks

### `GPGA_SERVICE_KIND_ASYNC_AND_ARRAY`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_ASYNC_AND_ARRAY = 38u;
```

**Description**: `$async$and$array` - PLA async AND array setup.

**Verilog**: `$async$and$array(mem, in_terms, out_terms);`

---

### `GPGA_SERVICE_KIND_SYNC_OR_PLANE`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_SYNC_OR_PLANE = 39u;
```

**Description**: `$sync$or$plane` - PLA sync OR plane setup.

**Verilog**: `$sync$or$plane(mem, in_terms, out_terms);`

---

### `GPGA_SERVICE_KIND_ASYNC_NOR_PLANE`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_ASYNC_NOR_PLANE = 40u;
```

**Description**: `$async$nor$plane` - PLA async NOR plane setup.

**Verilog**: `$async$nor$plane(mem, in_terms, out_terms);`

---

### `GPGA_SERVICE_KIND_SYNC_NAND_PLANE`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_SYNC_NAND_PLANE = 41u;
```

**Description**: `$sync$nand$plane` - PLA sync NAND plane setup.

**Verilog**: `$sync$nand$plane(mem, in_terms, out_terms);`

---

### `GPGA_SERVICE_KIND_SHOWCANCELLED`

```cpp
constant constexpr uint GPGA_SERVICE_KIND_SHOWCANCELLED = 42u;
```

**Description**: Cancellation report for specify-path delays when
`showcancelled` is in effect.

**Verilog**: `showcancelled` / `noshowcancelled` path options.

**Arguments** (numeric): `delay_id`, `index_val`, `index_xz`, `time`.

---

## Code Generation Macros

### `GPGA_SCHED_DEFINE_CONSTANTS`

```cpp
GPGA_SCHED_DEFINE_CONSTANTS(
    proc_count, root_count, event_count, edge_count, 
    edge_star_count, max_ready, max_time, max_nba, 
    repeat_count, delay_count, max_dnba, 
    monitor_count, monitor_max_args, strobe_count,
    service_max_args, service_wide_words, string_count
)
```

**Purpose**: Defines all compile-time scheduler capacity constants.

**Parameters**:
- `proc_count`: Total number of concurrent processes (initial/always blocks, fork children)
- `root_count`: Number of root-level processes (no parent)
- `event_count`: Number of named events (Verilog `event` declarations)
- `edge_count`: Number of edge-sensitive event controls
- `edge_star_count`: Number of combinational sensitivity lists (`@*`)
- `max_ready`: Maximum processes ready simultaneously
- `max_time`: Maximum entries in time-wheel queue
- `max_nba`: Maximum non-blocking assignments per time step
- `repeat_count`: Number of repeat loops in the design
- `delay_count`: Number of delay statements
- `max_dnba`: Maximum delayed non-blocking assignments
- `monitor_count`: Number of active `$monitor` statements
- `monitor_max_args`: Maximum arguments to any `$monitor`
- `strobe_count`: Number of active `$strobe` statements
- `service_max_args`: Maximum arguments to any service call
- `service_wide_words`: Number of 64-bit words for widest service argument
- `string_count`: Number of string literals in the design

**Generated Constants**:
```cpp
constant constexpr uint GPGA_SCHED_PROC_COUNT = proc_count;
constant constexpr uint GPGA_SCHED_ROOT_COUNT = root_count;
// ... (all parameters become constants)
```

**Usage**: Invoke once per compilation unit after including `gpga_sched.h`.

---

### `GPGA_SCHED_DEFINE_INDEX`

```cpp
GPGA_SCHED_DEFINE_INDEX()
```

**Purpose**: Defines the indexing function for accessing per-process state in GPU arrays.

**Generated Function**:
```cpp
inline uint gpga_sched_index(uint gid, uint pid)
```

**Parameters**:
- `gid`: GPU grid ID (workgroup/thread group)
- `pid`: Process ID (0 to `GPGA_SCHED_PROC_COUNT-1`)

**Returns**: Linear index into scheduler state arrays.

**Notes**: Enables parallel simulation of multiple design instances on the GPU.

---

### `GPGA_SCHED_DEFINE_SERVICE_RECORD_SIMPLE`

```cpp
GPGA_SCHED_DEFINE_SERVICE_RECORD_SIMPLE()
```

**Purpose**: Defines the simple (≤64-bit) service record structure.

**Generated**: `struct GpgaServiceRecord` without wide storage.

**Usage**: Use when no system task argument exceeds 64 bits.

---

### `GPGA_SCHED_DEFINE_SERVICE_RECORD_WIDE`

```cpp
GPGA_SCHED_DEFINE_SERVICE_RECORD_WIDE()
```

**Purpose**: Defines the wide (>64-bit) service record structure.

**Generated**: `struct GpgaServiceRecord` with `arg_wide_val` and `arg_wide_xz` arrays.

**Usage**: Required when any system task argument is wider than 64 bits.

---

### `GPGA_SCHED_DEFINE_PROC_PARENT`

```cpp
GPGA_SCHED_DEFINE_PROC_PARENT(parent0, parent1, parent2, ...)
```

**Purpose**: Defines the process parent relationship table.

**Parameters**: Variadic list of parent process IDs (one per process).

**Generated**:
```cpp
constant uint gpga_proc_parent[GPGA_SCHED_PROC_COUNT] = { parent0, parent1, ... };
```

**Usage**: 
- Use `GPGA_SCHED_NO_PARENT` for root processes
- Use parent process ID for forked children

**Example**:
```cpp
// Process 0 and 1 are roots, Process 2 is child of 0
GPGA_SCHED_DEFINE_PROC_PARENT(
    GPGA_SCHED_NO_PARENT,  // Process 0: root
    GPGA_SCHED_NO_PARENT,  // Process 1: root
    0                       // Process 2: child of 0
)
```

---

### `GPGA_SCHED_DEFINE_PROC_JOIN_TAG`

```cpp
GPGA_SCHED_DEFINE_PROC_JOIN_TAG(tag0, tag1, tag2, ...)
```

**Purpose**: Defines join tags for fork/join synchronization.

**Parameters**: Variadic list of join tag IDs (one per process).

**Generated**:
```cpp
constant uint gpga_proc_join_tag[GPGA_SCHED_PROC_COUNT] = { tag0, tag1, ... };
```

**Usage**: 
- Processes with the same non-zero join tag are joined together
- Use 0 for processes not involved in join synchronization

**Example**:
```cpp
// Processes 1 and 2 are in join group 1
GPGA_SCHED_DEFINE_PROC_JOIN_TAG(
    0,  // Process 0: no join
    1,  // Process 1: join group 1
    1   // Process 2: join group 1
)
```

---

## Usage Examples

### Example 1: Basic Scheduler Configuration

```cpp
#include "gpga_sched.h"

// Define scheduler capacity (analyzed from Verilog source)
GPGA_SCHED_DEFINE_CONSTANTS(
    10,   // 10 processes
    2,    // 2 root processes (initial blocks)
    3,    // 3 named events
    5,    // 5 edge-sensitive controls
    2,    // 2 combinational blocks (@*)
    10,   // Max 10 ready processes
    100,  // Max 100 time queue entries
    50,   // Max 50 NBAs per step
    5,    // 5 repeat loops
    20,   // 20 delay statements
    10,   // Max 10 delayed NBAs
    2,    // 2 monitor statements
    8,    // Max 8 args to any monitor
    1,    // 1 strobe statement
    8,    // Max 8 args to any service
    0,    // No wide arguments
    15    // 15 string literals
)

// Define index function
GPGA_SCHED_DEFINE_INDEX()

// Define simple service record (no wide args)
GPGA_SCHED_DEFINE_SERVICE_RECORD_SIMPLE()

// Define process hierarchy
GPGA_SCHED_DEFINE_PROC_PARENT(
    GPGA_SCHED_NO_PARENT,  // Process 0: initial block
    GPGA_SCHED_NO_PARENT,  // Process 1: always block
    0, 0, 0,               // Processes 2-4: forked from 0
    1, 1,                  // Processes 5-6: forked from 1
    2, 2, 3                // Processes 7-9: nested forks
)

// Define join tags (processes 2-4 join together)
GPGA_SCHED_DEFINE_PROC_JOIN_TAG(
    0,                     // Process 0: no join
    0,                     // Process 1: no join
    1, 1, 1,              // Processes 2-4: join group 1
    0, 0, 0, 0, 0         // Processes 5-9: no join
)
```

---

### Example 2: Wide Arguments

```cpp
#include "gpga_sched.h"

// Design with 256-bit system task arguments
GPGA_SCHED_DEFINE_CONSTANTS(
    5, 1, 0, 0, 0, 5, 20, 10, 0, 5, 5,
    1, 6, 0,
    6,    // Max 6 args
    4,    // Wide args need 4 words (256 bits)
    10
)

GPGA_SCHED_DEFINE_INDEX()

// Use wide service record
GPGA_SCHED_DEFINE_SERVICE_RECORD_WIDE()

// Example service record population:
void populate_display_256bit(GpgaServiceRecord& rec, uint pid) {
    rec.kind = GPGA_SERVICE_KIND_DISPLAY;
    rec.pid = pid;
    rec.format_id = 0;  // "%h"
    rec.arg_count = 1;
    rec.arg_kind[0] = GPGA_SERVICE_ARG_WIDE;
    rec.arg_width[0] = 256;
    
    // Value stored across multiple 64-bit words
    rec.arg_wide_val[0] = 0x123456789ABCDEFul;  // Bits 0-63
    rec.arg_wide_val[1] = 0xFEDCBA987654321ul;  // Bits 64-127
    rec.arg_wide_val[2] = 0xABCDEF0123456789ul;  // Bits 128-191
    rec.arg_wide_val[3] = 0x9876543210FEDCBAul;  // Bits 192-255
    
    // All bits are known (no X/Z)
    rec.arg_wide_xz[0] = 0;
    rec.arg_wide_xz[1] = 0;
    rec.arg_wide_xz[2] = 0;
    rec.arg_wide_xz[3] = 0;
}
```

---

### Example 3: Wait State Checking

```cpp
// Check if process is waiting for time advancement
bool is_time_blocked(uint wait_kind) {
    return wait_kind == GPGA_SCHED_WAIT_TIME ||
           wait_kind == GPGA_SCHED_WAIT_DELTA;
}

// Check if process can make progress
bool can_execute(uint proc_state, uint wait_kind) {
    if (proc_state == GPGA_SCHED_PROC_DONE) {
        return false;
    }
    if (proc_state == GPGA_SCHED_PROC_READY) {
        return wait_kind == GPGA_SCHED_WAIT_NONE;
    }
    return false;
}
```

---

### Example 4: Edge Detection Setup

```cpp
// Edge-sensitive control for: @(posedge clk or negedge rst)
struct EdgeControl {
    uint kind;      // GPGA_SCHED_EDGE_LIST
    uint signal_count;
    uint signal_ids[2];
    uint edge_types[2];
};

EdgeControl setup_clk_rst_edge() {
    EdgeControl ec;
    ec.kind = GPGA_SCHED_EDGE_LIST;
    ec.signal_count = 2;
    ec.signal_ids[0] = clk_signal_id;
    ec.signal_ids[1] = rst_signal_id;
    ec.edge_types[0] = GPGA_SCHED_EDGE_POSEDGE;
    ec.edge_types[1] = GPGA_SCHED_EDGE_NEGEDGE;
    return ec;
}
```

---

### Example 5: Service Record Processing

```cpp
// Process a $display service request
void handle_display_service(const GpgaServiceRecord& rec) {
    if (rec.kind != GPGA_SERVICE_KIND_DISPLAY) return;
    
    // Get format string from string table
    const char* format = get_format_string(rec.format_id);
    
    // Process each argument
    for (uint i = 0; i < rec.arg_count; ++i) {
        switch (rec.arg_kind[i]) {
            case GPGA_SERVICE_ARG_VALUE:
                // Print integer value
                printf_arg(rec.arg_val[i], rec.arg_width[i]);
                break;
                
            case GPGA_SERVICE_ARG_REAL:
                // Interpret as double
                double d = *reinterpret_cast<const double*>(&rec.arg_val[i]);
                printf_real(d);
                break;
                
            case GPGA_SERVICE_ARG_STRING:
                // Index into string table
                printf_string(get_string(rec.arg_val[i]));
                break;
                
            case GPGA_SERVICE_ARG_WIDE:
                // Reconstruct wide value
                print_wide_value(&rec.arg_wide_val[i * GPGA_SCHED_SERVICE_WIDE_WORDS],
                                &rec.arg_wide_xz[i * GPGA_SCHED_SERVICE_WIDE_WORDS],
                                rec.arg_width[i]);
                break;
        }
    }
    printf("\n");
}
```

---

## Implementation Notes

### Scheduling Algorithm

The scheduler implements the IEEE 1364-2005 event queue semantics:

1. **Initialization Phase** (time 0):
   - Execute all initial blocks
   - Evaluate all continuous assignments
   - Set `GPGA_SCHED_FLAG_ACTIVE_INIT`

2. **Active Events**:
   - Execute ready processes (blocking assignments, procedural code)
   - Evaluate continuous assignments
   - Execute `$display`, `$write`
   - Collect non-blocking assignment targets

3. **Non-Blocking Assignment Update**:
   - Apply all NBA RHS values to LHS targets
   - Propagate changes through continuous assignments

4. **Monitor Events**:
   - Execute `$monitor` if any monitored signal changed

5. **Time Advancement**:
   - If no active events, advance to next scheduled time
   - Execute `$strobe` statements for completed time step

### Parallelization Strategy

- Each GPU thread simulates one or more complete design instances
- Process state arrays are indexed by `gpga_sched_index(gid, pid)`
- Service records are accumulated in thread-local queues
- Host runtime processes service requests between kernel invocations

### Memory Layout

All scheduler state is stored in flat arrays for GPU efficiency:
- Process states, wait kinds, resume times
- Event trigger queues
- NBA pending updates
- Service record buffers

---

## Performance Considerations

1. **Array Sizing**: Tight bounds improve GPU occupancy and cache utilization
2. **Service Batching**: Minimize kernel launches by batching service requests
3. **Constant Memory**: Small constant arrays (parent, join tags) use constant memory
4. **Branch Divergence**: Process states may cause thread divergence (optimized by scheduler)

---

## See Also

- [GPGA_4STATE_API.md](GPGA_4STATE_API.md) - Four-state logic for signal values
- [GPGA_WIDE_API.md](GPGA_WIDE_API.md) - Wide integer support for >64-bit values
- [GPGA_REAL_API.md](GPGA_REAL_API.md) - Real number (floating-point) support
- [VERILOG_TEST_OVERVIEW.md](VERILOG_TEST_OVERVIEW.md) - Testing methodology

---

## Version History

- **Initial Version**: Complete IEEE 1364/1800 scheduler infrastructure for GPU-accelerated Verilog simulation.
